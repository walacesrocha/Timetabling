%% LyX 1.3 created this file.  For more info, see http://www.lyx.org/.
%% Do not edit unless you really know what you are doing.
\documentclass[brazil,ruledheader]{abnt}
\usepackage[T1]{fontenc}
\usepackage[latin1]{inputenc}
%\usepackage[vlined,boxruled,linesnumbered,portuguese]{algorithm2e}
\usepackage[ruled,longend,lined,linesnumbered,portuguese]{algorithm2e}
% Escrita dos algoritmos
\usepackage{amssymb,amsmath}
%\usepackage[dvipdf]{graphicx,color}
\usepackage{graphicx,color}
\usepackage{lscape}



\makeatletter
\usepackage{babel}
\makeatother
\begin{document}

\autor{Walace de Souza Rocha}


\titulo{Algoritmo GRASP para o Problema de Tabela-horário de Universidades}


\orientador{Maria Claudia Silva Boeres}


\coorientador{Maria Cristina Rangel}


\comentario{Dissertação apresentada para obtenção do Grau de Bacharel em Ciência
da Computação pela Universidade Federal do Espírito Santo.}


\instituicao{Departamento de Informática \par Centro Tecnológico\par Universidade
Federal do Espírito Santo}


\local{Vitória - ES, Brasil}


\data{28 de Fevereiro de 2013}

\capa

\folhaderosto

\begin{folhadeaprovacao}
Dissertação de Projeto Final de Graduação sob o título \textit{``\ABNTtitulodata''},
defendida por \ABNTautordata~e aprovada em \ABNTdatadata, em Vitória,
Estado do Espírito Santo, pela banca examinadora constituída pelos
professores: \setlength{\ABNTsignthickness}{0.4pt}

\assinatura{Profa. Dr. Maria Claudia Silva Boeres\\ Orientadora}
\assinatura{Profa. Dr. Maria Cristina Rangel\\ Co-orientadora}
\assinatura{Prof. Dr. Fulano de Tal\\ Universidade Federal do Espírito Santo}
\end{folhadeaprovacao}
\begin{resumo}
Escreva aqui o texto do seu resumo.
\end{resumo}
\begin{abstract}
Write here the English version of your {}``Resumo''.
\end{abstract}

\chapter*{Dedicatória}

Dedico este trabalho a ...


\chapter*{Agradecimentos}

Agradeço a ...

\tableofcontents{}\listoffigures



\listoftables

\listofalgorithms


\chapter{Introdução\label{cap:introducao}}

\vfill{}
\vfill{}

Neste capítulo são apresentados o objetivo desta dissertação e a estrutura
da mesma.
\newpage

\section{Apresentação do problema}

O problema de tabela-horário consiste em alocar um conjunto de aulas em um número pré-determinado de horários, satisfazendo diversas restrições envolvendo professores, alunos e o espaço físico disponível. A solução manual deste problema não é uma tarefa trivial e as instituições de ensino precisam resolvê-lo anualmente ou semestralmente. Nem sempre a alocação manual é satisfatória, por exemplo, quando um aluno não consegue matricular em duas disciplinas porque elas são alocadas no mesmo horário.

Por esta razão, atenção especial tem sido dada a solução automática de tabela-horário. Nos últimos cinquenta anos, começando com \cite{gotlieb62}, este problema ganhou grande destaque na área de otimização combinatória, tendo diversos trabalhos publicados.

\section{Motivação para o problema}

O problema de tabela-horário está entre os mais difíceis da área de otimização combinatória. Em \cite{Schaerf95asurvey} pode ser visto que ele é classificado como NP-completo. Assim, a solução exata só pode ser garantida para instâncias bem pequenas, que não correspondem às instâncias reais da maioria das instituições de ensino.

Existe uma necessidade de propor algoritmos cada vez mais eficientes que produzam tabelas-horário satisfatórias em um tempo viável, independente do tamanho da instância. Devido à complexidade do problema, métodos exaustivos são descartados. Diferentes meta-heurísticas tem sido aplicadas devido ao fato de serem relativamente simples de implementar e produzirem bons resultados. Dentre as meta-heurísticas que já foram aplicadas ao problema, existe um esforço em aplicar melhorias para conseguir melhores resultados. Há algumas meta-heurísticas que ainda não foram exploradas no problema, o que deixa uma incógnita quanto à sua eficiência.

\section{Objetivos deste trabalho}

O objetivo principal deste trabalho é resolver o problema de tabela-horário de universidades usando a meta-heurística GRASP (\textit{Greedy Randomized Adaptive Search Procedures}). Pelo fato de existirem diversas formulações para o problema, será escolhida uma que tem sido bastante utilizada na área: a que é proposta no ITC-2007 (\textit{International Timetabling Competition - 2007}) \cite{itc2007}. A razão principal desta escolha é facilitar a comparação dos resultados com outros algoritmos propostos na literatura.

Para atingir este objetivo será necessário estudar a formulação do ITC-2007 e propor uma implementação eficiente dos dados. Além de aplicar o GRASP para o problema, pretende-se implementar algumas melhorias que já foram propostas na literatura e que visam melhorar a versão básica do algoritmo.

Vale ressaltar que o ITC-2007 dividiu o campeonato em três \textit{tracks}. Cada \textit{track} possui uma formulação específica e seu próprio conjunto de instâncias. O \textit{track} 1 é uma formulação específica para aplicação de exames finais. Os \textit{tracks} 2 e 3 tratam a alocação semanal das aulas de uma universidade. A diferença básica é que o \textit{track} 2, chamado de \textit{post enrolment} (pós matrícula) trata o problema considerando os dados de matrícula dos alunos, enquanto que no 3 as informações levam em conta os currículos que compõe a universidade.

Será adotado neste trabalho a formulação do \textit{track} 3 por ser considerada, dentre as três, a mais próxima do que acontece na prática nas universidades brasileiras. Esta formulação será explicada em detalhes no capítulo \ref{cap:proposta-trabalho}.

Deseja-se por fim coletar na literatura resultados obtidos para o problema com diferentes técnicas de solução, a fim de comparar com o algoritmo proposto.


\section{Organização do texto}

No capítulo \ref{cap:estado-da-arte} é apresentado o estado da arte listando as principais técnicas de solução do problema. No capítulo \ref{cap:proposta-trabalho} são apresentados a formulação do problema segundo o ITC-2007, o algoritmo GRASP e sua aplicação no problema. No capítulo \ref{cap:resultados} são apresentados detalhes de implementação, instâncias de testes e os resultados obtidos. No capítulo \ref{cap:conclusao} são listadas as conclusões obtidas no trabalho e enumerados alguns trabalhos futuros.


\chapter{Estado da Arte\label{cap:estado-da-arte}}

\vfill{}
\begin{flushright}{}``\emph{Navegar é preciso, viver não.}''\\
{\small Luís de Camões}\end{flushright}{\small \par}
\vfill{}

Neste capítulo são apresentados ....
\newpage


\section{Introdução}

O problema de tabela-horário não possui uma formulação única. Como pode ser visto em \cite{Schaerf95asurvey}, ao longo do tempo surgiram diversas modelagens. Essa variedade surgiu pelo fato das restrições do problema serem específicas a determinada instituição de ensino. Alguns \textit{benchmarks} foram criados, como é o caso do ITC-2007 \cite{itc2007}. A maior contribuição do \textit{benchmark} é fornecer um conjunto de dados para que os diferentes pesquisadores possam comparar suas técnicas de solução.

Apesar das diferentes formulações, os problemas de tabela-horário possuem uma característica em comum: a separação das restrições em dois grupos. São fortes ou fracas.

As restrições fortes são aquelas que não podem ser violadas. Elas restringem o conjunto de soluções para impedir certas situações irreais, como por exemplo, alunos assistindo mais de uma aula no mesmo tempo ou uma sala sendo alocada para mais de uma aula no mesmo horário. Se uma tabela-horário não viola nenhuma restrição forte ela é dita ser uma solução viável.

As restrições fracas são aquelas que não interferem na viabilidade da solução, mas refletem certas preferências das instituições. É desejável, por exemplo, que um aluno não tenha aulas isoladas durante o dia ou que aulas da mesma disciplina sejam lecionadas na mesma sala. As restrições fracas podem possuir pesos diferentes.

O objetivo do problema é encontrar uma tabela-horário viável e que minimize a quantidade de violações fracas, portanto, um problema de minimização.

\section{Conceitos e definições}

As diversas formulações do problema apresentadas na literatura variam devido à instituição envolvida (escola ou universidade) e também pelo conjunto de restrições que são abordadas. Contudo, todas as formulações podem ser classificadas em uma das três classes principais \cite{Schaerf95asurvey}:

\begin{itemize}

\item \textbf{Tabela-horário de Escola} Programação semanal para as turmas da escola, evitando que professores lecionem para duas turmas ao mesmo tempo ou que turmas assistam mais de uma aula no mesmo horário.

\item \textbf{Tabela-horário de Universidade} Programação semanal das aulas das disciplinas universitárias, minimizando a sobreposição de aulas que tenham alunos em comum.

\item \textbf{Tabela-horário de Exames} Programação para aplicação dos exames das disciplinas, evitando sobreposição de exames das disciplinas que tenham alunos em comum, e espalhando os exames para os alunos o máximo possível.

\end{itemize}

A tabela-horário de exames é usada somente nos finais de bimestre, trimestre ou semestre, enquanto as duas primeiras durante todo o período letivo. A diferença principal do problema no âmbito de escolas e universidades é que no segundo não há o conceito de turma, já que cada aluno escolhe o conjunto de disciplinas que irá cursar. Já nas escolas (primárias e secundárias) todos alunos matriculados numa turma cursam as mesmas disciplinas.

\section{Abordagens existentes\label{sec:abordagens}}

As técnicas usadas para resolver o problema de tabela-horário são bastante diversificadas. As mais antigas, as heurísticas construtivas \cite{Junginger:1986:TGS,papoulias}, foram baseadas no modo humano de resolver o problema: as aulas eram alocadas uma a uma até finalizar a construção da tabela. Conflitos eram resolvidos realizando trocas de aulas.

\cite{Neufeld} propôs uma redução do problema ao problema de coloração de grafos. As aulas são representadas como vértices do grafo. Arestas conectam aulas que não podem ser alocadas no mesmo horário. A coloração do grafo resultante é então transformada na tabela-horário: cada cor representa um horário de aula. Propostas similares a esta foram aplicadas em \cite{deWerra85,Selim:1988}.

\cite{deWerra82} reduziram o problema de tabela-horário ao problema de fluxo de redes. As aulas são representadas pelos vértices. Uma rede é criada para cada horário e o fluxo na rede identifica as aulas que são lecionadas no mesmo horário. Posteriormente, \cite{deWerra85} usou uma idéia similar, mas cada fluxo representa uma classe e os vértices são horários e professores. Outras abordagens com fluxo de redes foram usadas em \cite{dinkel1989or,chahal1989}.

De uns anos para cá as técnicas de solução para o problema têm recaído basicamente em três grupos: programação matemática, programação em lógica e principalmente meta-heurísticas.

Na área de programação matemática, bons resultados têm sido obtidos com programação inteira. Em \cite{lach_lubbecke} pode ser vista uma formulação completa do problema. Ela foi executada com CPLEX9 \cite{cplex} e conseguiu soluções com respostas bem próximas às melhores obtidas na competição ITC-2007. Em \cite{Burke_abranch-andcut} pode ser vista outra formulação com algumas relaxações. Com um tempo de execução aproximado de quinze minutos no CPLEX10, esse algoritmo conseguiu encontrar a solução ótima para duas instâncias da competição. Uma grande contribuição destes dois trabalhos é que eles forneceram limites inferiores para a quantidade de violações das restrições fracas para cada instância do ITC-2007. Em \cite{ribeiro2006integer} pode ser vista uma modelagem em programação inteira mais específica para escolas brasileiras de ensino fundamental.

Alguns resultados relevantes também tem sido encontrados com programação em lógica. \cite{springerlink:10.1007/s10479-012-1081-x} apresenta uma formulação usando \textit{MaxSAT} em que se conseguiu melhorar quase metade das respostas que eram conhecidas à época para as instâncias do ITC-2007. \cite{Gueret95buildinguniversity} e \cite{Goltz99universitytimetabling} adotam formulações diferentes do ITC-2007, mas destacam como programação em lógica combinada com programação por restrições podem implementar modelos bem flexíveis, em que restrições podem ser adicionadas, modificadas ou excluídas com pouca alteração de código-fonte.

Pode ser visto em \cite{Lewis2007:survey} que grande parte dos trabalhos recentes na área tem usado meta-heurísticas, tanto pela simplicidade quanto pelos bons resultados alcançados. Meta-heurísticas são estruturas gerais de algoritmos que podem ser adaptados para diferentes problemas de otimização necessitando em geral pouca implementação específica \cite{Lewis2007:survey}.  \textit{Simulated Annealing}, Algoritmo Genético e Busca Tabu são as mais aplicadas. Há propostas com meta-heurísticas menos conhecidas, como a Busca de Harmonia \cite{albetar_harmony}.

Em \cite{Elmohamed98acomparison} foram investigadas diversas abordagens do \textit{Simulated Annealing}. Dentre as configurações possíveis, os melhores resultados foram obtidos com resfriamento adaptativo, reaquecimento e um algoritmo baseado em regras para gerar uma boa solução inicial. \cite{CDGS11b} usa SA para resolver a formulação \textit{track 2} do ITC-2007. Neste trabalho foram obtidas boas respostas para as instâncias, e em alguns casos, foram conhecidas respostas melhores que às conhecidas à época.

Algoritmos Genéticos também foram propostos para o problema. O cromossomo representa a tabela-horário. Cada posição da tabela corresponde a um gene. A partir daí são definidas as operações genéticas de seleção, cruzamento e mutação, que visam gerar indivíduos cada vez melhores. Um indivíduo com bom valor \textit{fitness} representa uma tabela-horário bem avaliada de acordo com a função objetivo associada ao problema. \cite{Erben95agenetic} aplicou esta técnica para tratar o problema de tabela-horário de universidades com muitas restrições, obtendo resultados promissores. Em \cite{Kanoh:2008:KGA} pode ser visto uma abordagem também para universidades, em que se utiliza uma base de conhecimento para gerar a população inicial. Essa base de conhecimento é formada com informações de tabelas-horário de anos anteriores. \cite{massoodian2008} propôs um algoritmo genético híbrido para resolver a formulação do ITC-2007. O algoritmo foi chamado de híbrido porque além de aplicar os operadores genéticos, uma busca local era aplicada nos melhores indivíduos ao final de cada geração.

Um algoritmo mais simples que o genético, mas que também tem sido aplicado é a Busca Tabu. Em \cite{elloumi2008} é apresentado uma algoritmo para resolver o problema de tabela-horário de uma universidade tunisiana. \cite{Santos:2005:TSH} aplicou a técnica no âmbito de escolas primárias e obteve respostas melhores que outros algoritmos propostos com Busca Tabu. Em \cite{Souza:2004:GSA} a Busca Tabu é aplicada como fase de busca local do GRASP, numa implementação também voltada para escolas.

Devido à dificuldade de otimização do problema, alguns autores têm proposto técnicas híbridas, em que são usadas mais de uma meta-heurística ou aplicadas de forma diferente. Exemplos deste tipo de implementação podem ser visto em \cite{massoodian2008} em que o algoritmo genético é combinado com um algoritmo de busca local para melhorar a qualidade das soluções. Em \cite{3-phaseSA} há um algoritmo para o ITC-2002 que constrói a tabela-horário em três etapas. Na primeira é usada um algoritmo de coloração de grafos para se obter uma solução inicial viável. Na segunda e terceira etapas aplica-se \textit{Simulated Annealing}, mas cada uma usando uma estrutura de vizinhança diferente. Como dito anteriormente, em \cite{Souza:2004:GSA} a Busca Tabu é inserida dentro da meta-heurística GRASP para melhorar a fase de busca local desta.

\section{Trabalhos relacionados}

O objetivo deste trabalho é propor um novo algoritmo usando a meta-heurística GRASP para o problema de tabela-horário de universidades. O GRASP já foi implementado no problema, mas para tabela-horário de escolas. Como mostrada na seção anterior, \cite{Souza:2004:GSA} usou o GRASP juntamente com busca Tabu. Outra implementação do GRASP pode ser vista em \cite{Vieira_agrasp}, onde foi implementada a versão básica do algoritmo e uma estratégia de intensificação.

A formulação adotada neste trabalho é a do ITC-2007. Como foi visto na seção \ref{sec:abordagens} muitos trabalhos foram propostos para resolver esta formulação. Mas nenhuma conseguiu obter soluções ótimas para todas as instâncias, o que gera uma motivação para continuar buscando novos resultados. Os melhores resultados encontrados até agora estão em \cite{lach_lubbecke,Burke_abranch-andcut,springerlink:10.1007/s10479-012-1081-x,CDGS11b}.

\chapter{Proposta do trabalho\label{cap:proposta-trabalho}}

\vfill{}
\begin{flushright}{}``\emph{Nada se cria, nada se perde, tudo se
transforma.}''\\
{\small Lavousier}\end{flushright}{\small \par}
\vfill{}

Neste capítulo é apresentado a proposta do trabalho
...
\newpage

\section{Formulação do ITC-2007\label{sec:formulacao}}

Nesta seção é apresentada a formulação que foi utilizada neste trabalho, que é o \textit{track} 3 do ITC-2007.

O problema de tabela-horário segundo esta formulação utiliza os seguintes parâmetros:

\begin{itemize}

\item \textbf{Dias, Horários e Períodos}: É dado o número de dias na semana em que há aula (geralmente cinco ou seis). Um número fixo de horários de aula, igual para todos os dias, é estabelecido. Um período é um par composto de um dia e um horário. O total de períodos é obtido multiplicando a quantidade de dias pela quantidade de horários do dia.

\item \textbf{Disciplinas e Professores}: Cada disciplina possui uma quantidade de aulas semanais que devem ser alocadas em períodos diferentes. É lecionada por um professor e assistida por um dado número de alunos. Um número mínimo de dias é determinado para a distribuição de suas aulas na semana e é possível que um professor lecione mais de uma disciplina.

\item \textbf{Salas}: Cada sala possui uma capacidade diferente de assentos.

\item \textbf{Currículo}: Um currículo é um grupo de disciplinas que possuem alunos em comum.

\item \textbf{Indisponibilidades} Alguns períodos são indisponíveis para determinadas disciplinas.

\end{itemize}

Uma solução consiste na alocação de cada aula em um período e uma sala. As restrições do problema, fortes e fracas, são descritas a seguir.

\subsection{Restrições Fortes (RFt)}

\begin{itemize}

\item \textbf{Aulas}: Todas as aulas das disciplinas devem ser alocadas e em períodos diferentes. Uma violação ocorre se uma aula não é alocada. (RFt1)

\item \textbf{Conflitos}: Aulas de disciplinas do mesmo currículo ou lecionadas pelo mesmo professor devem ser alocadas em períodos diferentes. (RFt2)

\item \textbf{Ocupação de Sala}: Duas aulas não podem ocupar uma sala no mesmo horário. (RFt3)

\item \textbf{Disponibilidade}: Uma aula não pode ser alocada num horário em que a disciplina é indisponível. (RFt4)

\end{itemize}

\subsection{Restrições Fracas (RFc)}

\begin{itemize}

\item \textbf{Dias Mínimos de Trabalho}: As aulas de cada disciplina devem ser espalhadas por uma quantidade mínima de dias. Cada dia abaixo do mínimo é contado como uma violação. (RFc1)

\item \textbf{Aulas Isoladas}: Aulas do mesmo currículo devem ser alocadas em períodos adjacentes. Cada aula isolada é contada como uma violação. (RFc2)

\item \textbf{Capacidade da Sala}: O número de alunos da disciplina deve ser menor ou igual ao número de assentos da sala em que a aula for dada. Cada aluno excedente contabiliza uma violação. (RFc3)

\item \textbf{Estabilidade de Sala}: Todas as aulas de uma disciplina devem ser dadas na mesma sala. Cada sala distinta é contada como uma violação. (RFc4)

\end{itemize}

Na contagem total das violações fracas são considerados pesos diferentes para cada tipo de violação. A restrição de dias mínimos possui peso cinco, aulas isoladas, peso dois e as demais, peso um.

Uma solução viável deve atender a todas as restrições fortes. Uma solução ótima é viável e minimiza a função objetivo apresentada na equação \ref{funcaoObjetivo}:

\begin{equation}\label{funcaoObjetivo}
%\begin{split}
f = \text{Violações}_{RFt} + \text{Violações}_{RFc}
%\end{split}
\end{equation}

\noindent onde $\text{Violações}_{RFt} = |RFt1|_v + |RFt2|_v + |RFt3|_v + |RFt4|_v$, $\text{Violações}_{RFc} = 5|RFc1|_v + 2|RFc2|_v + |RFc3|_v + |RFc4|_v$ e $|.|_v$ representa o número de violações.

A formulação do ITC-2007 é baseada em casos reais da Escola de Engenharia da Universidade de Udine na Itália. Algumas simplificações foram feitas para o campeonato para manter certo grau de generalidade.

Abaixo está ilustrado um arquivo exemplo para uma instância de teste, chamada \textit{Toy}. A primeira parte informa a quantidade de disciplinas, salas, dias, períodos por dia, currículos e indisponibilidades. Na segunda parte são detalhados dados das disciplinas: nome do professor, quantidade de aulas na semana, número mínimo de dias de aula e quantidade de alunos. A terceira parte lista as salas e suas respectivas capacidades. Logo após vem a relação dos currículos, com os nomes das disciplinas que compõe cada um deles. Por último são listadas as indisponibilidades das disciplinas, identificando dia e horário em que não podem ser lecionadas.

%\begin{boxed}
\begin{verbatim}
Name: Toy
Courses: 4
Rooms: 3
Days: 5
Periods_per_day: 4
Curricula: 2
Constraints: 8
 
COURSES:
SceCosC Ocra 3 3 30 
ArcTec Indaco 3 2 42
TecCos Rosa 5 4 40 
Geotec Scarlatti 5 4 18 
 
ROOMS:
rA 32 
rB 50 
rC 40 
 
CURRICULA:
Cur1 3 SceCosC ArcTec TecCos 
Cur2 2 TecCos Geotec 
 
UNAVAILABILITY_CONSTRAINTS:
TecCos 2 0 
TecCos 2 1 
TecCos 3 2 
TecCos 3 3 
ArcTec 4 0 
ArcTec 4 1 
ArcTec 4 2 
ArcTec 4 3 

END.
\end{verbatim}

A resposta para o problema é fornecida informando a sala, o dia e horário de cada aula, como no exemplo abaixo:

\begin{verbatim}
SceCosC rC 1 2
SceCosC rC 2 2
SceCosC rC 3 0
ArcTec rB 0 2
ArcTec rB 1 0
ArcTec rC 4 3
TecCos rC 0 1
TecCos rC 1 1
TecCos rC 2 3
TecCos rC 4 0
TecCos rC 4 2
Geotec rA 0 1
Geotec rA 1 0
Geotec rA 1 2
Geotec rA 1 3
Geotec rA 4 3
\end{verbatim}

A tabela \ref{tab:solucao_toy} apresenta uma vizualização desta resposta. Nesta tabela, \textit{SceCosC} é representada por SC, \textit{ArcTec} por AT, \textit{TecCos} por TC e \textit{Geotec} por GT.

\begin{center}
\begin{table}[!htb]
\begin{tabular}{|c|c|c|c|c||c|c|c|c||c|c|c|c||c|c|c|c||c|c|c|c|}\hline
 & \multicolumn{4}{|c||}{Dia 0} & \multicolumn{4}{|c||}{Dia 1}& \multicolumn{4}{|c||}{Dia 2}& \multicolumn{4}{|c||}{Dia 3}&  \multicolumn{4}{|c|}{Dia 4}\\ \hline
 & 0 & 1 & 2 & 3 & 0 & 1 & 2 & 3 & 0 & 1 & 2 & 3 & 0 & 1 & 2 & 3 & 0 & 1 & 2 & 3 \\ \hline
rA &  & GT & & & GT & & GT & GT & & &  & & & & &  &  &  &  & GT \\ \hline
rB &  &  & AT &  & AT &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  \\ \hline
rC &  & TC &  &  &  & TC & SC &  &  &  & SC & TC & SC &  &  &  & TC &  & TC & AT \\ \hline
\end{tabular}
\caption{Tabela-horário para a instância \textit{Toy}}
\label{tab:solucao_toy}
\end{table}
\end{center}

As seguintes violações fortes e fracas podem ser observadas na tabela-horário \ref{tab:solucao_toy}:

\begin{itemize}
\item RFt2 no dia 0, período 1: \textit{GeoTec} e \textit{TecCos} estão em conflito por pertecerem ao mesmo currículo \textit{Cur2}.
\item RFt4 no dia 4, período 3: \textit{ArcTec} é indisponível neste horário.
\item RFc1 para a disciplina \textit{GeoTec}: ela é lecionada em 3 dias, mas o mínimo requerido são 4.
\item RFc2 no dia 4, período 0: Uma aula da disciplina \textit{TecCos} está isolada.
\item RFc3 no dia 4, período 3: A disciplina \textit{ArcTec} possui 42 alunos mas a capacidade de \textit{rC} é apenas 40.
\item RFc4 para a disciplina \textit{ArcTec}: está sendo lecionada em duas salas diferentes: \textit{rB} e \textit{rC}.
\end{itemize}


\section{Algoritmo GRASP}

Um problema de otimização combinatória pode ser definido por um conjunto finito $E = {1,...,n}$, um conjunto de soluções viáveis $F \subseteq 2^E$ e uma função objetivo $f : 2^E \rightarrow \mathbb{R}$, todos definidos para cada problema específico. Considerando a versão de minimização, o objetivo consiste em encontrar uma solução ótima $S^* \in F$ tal que $f(S^*) \leq f(S), \forall S \in F$. 

As meta-heurísticas são algoritmos gerais que orientam uma forma de explorar o conjunto de soluções para encontrar a solução ótima. A solução ótima não é garantida, mas elas em geral conseguem boas soluções.

A meta-heurística GRASP (\textit{Greedy Randomized Adaptive Search Procedures} - Procedimentos de busca aleatória, adaptativa e gulosa) foi introduzida por \cite{FeoRes89} para tratar o problema de cobertura de conjuntos. De lá para cá ela já foi aplicada em vários problemas de otimização como conjunto independente máximo \cite{FeoResSmi94}, problema quadrático de alocação \cite{LiParRes94}, satisfabilidade \cite{ResFeo96a}, planarização de grafos \cite{ResRib95}, roteamento de circuitos virtuais \cite{ResRib03a}, entre outros.

\subsection{Estrutura básica}

O algoritmo GRASP é um procedimento multi-iterativo. Cada iteração constrói uma solução inicial e aplica busca local para melhorá-la. A resposta final é a melhor obtida dentre as iterações. O algoritmo \ref{algoGrasp} apresenta o pseudo-código genérico do GRASP. Ao fim da fase de construção inicial, pode ocorrer de a solução obtida ser inviável. Por isso um passo intermediário é previsto para reparar a solução, tornando-a viável.

\begin{algorithm}[H]
\label{algoGrasp}
\SetAlgoLined
\SetKwFunction{GeraSolucaoInicial}{GeraSolucaoInicial}
\SetKwFunction{BuscaLocal}{BuscaLocal}
\SetKwFunction{ReparaSolucao}{ReparaSolucao}
%\SetKwFunction{AtualizaPool}{AtualizaPool}
\Entrada{MaxIter}
\Saida{Solução $S^{*}$}

$f^{*} \leftarrow \infty $ \;
\Para{$i\leftarrow 1$ \Ate $MaxIter$}{
	$S \leftarrow GeraSolucaoInicial() $ \;
	\Se{$ S $ é inviável }{
		$ReparaSolucao(S) $\;
	}
	$S \leftarrow BuscaLocal(S) $ \;
	\Se{$ f(S) < f^{*} $}{
		$S^{*} \leftarrow S $ \;
		$f^{*} \leftarrow f(S) $ \;
	}
}
\caption{Estrutura básica do algoritmo GRASP}
\end{algorithm}

O método de construção da solução inicial do GRASP é guloso aleatório e visa produzir um conjunto diversificado de soluções iniciais de boa qualidade para a busca local. Algoritmos totalmente aleatórios conseguem essa diversificação, mas as soluções em geral são ruins considerando a função objetivo. Por outro lado, algoritmos gulosos tendem a gerar soluções de melhor qualidade, mas eles não conseguem produzir soluções diferentes já que a construção é sempre feita por escolhas gulosas.

O algoritmo \ref{solInicialGrasp} ilustra genericamente o procedimento de construção inicial. Ele recebe como parâmetro um conjunto de elementos que irão compor a solução. Cada iteração escolhe sucessivamente um novo elemento candidato para ser incorporado. Essa escolha é gulosa aleatória. Primeiramente todos os candidatos são avaliados por uma função $g(c)$ para medir o custo de adicionar o candidato $c$ à solução parcial $S$. Com base no menor e maior custo são escolhidos os candidatos mais bem avaliados para compor a lista restrita de candidatos - LRC. Um dos candidatos é escolhido aleatoriamente desta lista. Ao ser acrescentado à solução o elemento é retirado do conjunto de candidatos. O procedimento termina quando todos os elementos foram incorporados à solução e não há mais candidatos.

O parâmetro $\alpha (0 \leq \alpha \leq 1)$ regula se o algoritmo será mais guloso ou mais aleatório. Quando $\alpha$ é mais próximo de zero somente os elementos com baixo custo irão entrar na LRC. Este comportamento produz soluções de boa qualidade porém pouco diversificadas. Com $\alpha$ mais próximo de um, elementos com custo mais alto poderão também entrar na LRC. Isto introduz mais aleatoriedade à solução, mas em compensação se perde em qualidade. O ideal é encontrar um valor intermediário que permita diversificação sem prejudicar muito a qualidade de solução que será passada para a fase seguinte de busca local.

\begin{algorithm}[H]
\label{solInicialGrasp}
\SetAlgoLined
\SetKwFunction{GeraSolucaoInicial}{GeraSolucaoInicial}
\SetKwFunction{BuscaLocal}{BuscaLocal}
\SetKwFunction{PathRelinking}{PathRelinking}
\SetKwFunction{AtualizaPool}{AtualizaPool}
\Entrada{E = \{conjunto discreto finito\}}
\Saida{Solução S}

$S \leftarrow \emptyset $ \;
$C \leftarrow E $ \;
\Enqto{$|C| > 0$}{
	Para todo $c \in C$ computar o valor da função gulosa $g(c) $ \;
	$c^{min} \leftarrow min\{g(c) | c \in C\}$\;
	$c^{max} \leftarrow max\{g(c) | c \in C\}$\;
	$LRC \leftarrow \{ c \in C | g(c) \leq c^{min} + \alpha(c^{max} - c^{min}) \} $ \;
	Escolha aleatoriamente $c^{'} \in LRC $ \;
	$S \leftarrow S \bigcup \{ c^{'} \} $\;
	$C \leftarrow C - \{ c^{'} \}$ \;
}
\caption{Algoritmo guloso aletório para construção da solução inicial do GRASP}
\end{algorithm}

Para encontrar boas soluções, uma meta-heurística precisa ter duas características importantes: diversificação e intensificação. A primeira se refere à capacidade de explorar bem o espaço de soluções e não ficar preso a mínimos ou máximos locais. A intensificação é necessária para explorar bem uma região de mínimo local, dado que o mínimo global necessariamente também é um mínimo local.

No GRASP a diversificação é feita pela independência das iterações e pela aleatoriedade introduzida na solução inicial. Assim a busca local irá trabalhar em diferentes soluções.

A intensificação é feita pela busca local. Nesta fase a solução inicial é melhorada explorando sua vizinhança na busca de soluções melhores. O GRASP não especifica qual a estratégia de busca local deve ser utilizada. Em \cite{FeoResSmi94} a busca local implementada é conhecida como \textit{Hill Climbing}. É uma estratégia simples em que se explora a vizinhança enquanto são encontradas soluções melhores. Já em \cite{Souza:2004:GSA} por exemplo, é usado busca Tabu.

\subsection{Hibridização com \textit{Path-Relinking}}

A heurística \textit{Path-Relinking} (religamento de caminhos) foi originalmente proposta por \cite{Glover96tabusearch} como uma estratégia de intensificação na busca Tabu. A primeira proposta de uso do \textit{Path-Relinking} no GRASP foi feita por \cite{Laguna99graspand}. Essa hibridização tenta resolver uma deficiência do GRASP que é ausência de memorização entre as iterações.

A idéia básica do \textit{Path-Relinking} é traçar um caminho ligando duas soluções, que são chamadas de inicial e alvo. Para gerar este caminho, sucessivamente são inseridos atributos da solução alvo na solução inicial para que ela fique a cada iteração mais parecida com a solução alvo. A cada atributo inserido uma solução diferente é obtida. A melhor solução obtida no caminho é a resposta do algoritmo. Desta forma, o religamento de caminhos pode ser visto como uma estratégia que procura incorporar atributos de soluções de alta qualidade. O pseudo-código do algoritmo \ref{path-relinking} ilustra o PR aplicado ao par de soluções $x_i$ (inicial) e $x_a$ (alvo).

O procedimento inicia computando a diferença simétrica $\Delta(x_i,x_a)$ entre as duas soluções, isto é, o conjunto de movimentos necessários para alcançar $x_a$ a partir de $x_i$. Um caminho de soluções é gerado ligando $x_i$ e $x_a$. A melhor solução $x^*$ no caminho é retornada pelo algoritmo. Em cada iteração, o procedimento examina todos os movimentos $m \in \Delta(x, x_a)$ a partir da solução corrente $x$ e seleciona aquele que resulta no custo de solução menor, isto é, aquele que minimiza $f(x \oplus m)$, onde $x \oplus m$ é a solução resultante da aplicação do movimento $m$ à solução $x$. O melhor movimento $m^*$ é feito, produzindo a solução $x \oplus m^*$. O conjunto de movimentos possíveis é atualizado. Se for o caso, a melhor solução $x^*$ é atualizada. O procedimento termina quando $x_a$ é alcançada, ou seja, $\Delta(x, x_a) = \emptyset$.

\begin{algorithm}[H]
\label{path-relinking}
\SetAlgoLined
\SetKwFunction{GeraSolucaoInicial}{GeraSolucaoInicial}
\SetKwFunction{BuscaLocal}{BuscaLocal}
\SetKwFunction{PathRelinking}{PathRelinking}
\SetKwFunction{AtualizaPool}{AtualizaPool}
\Entrada{Solução inicial $x_i$, solução alvo $x_a$}
\Saida{Melhor solução $x^{*}$ no caminho de $x_i$ para $x_a$}

$f^{*} \leftarrow min \{ f(x_i), f(x_a) \} $ \;
$x^{*} \leftarrow argmin \{ f(x_i), f(x_a) \} $ \;
$x \leftarrow x_i $ \;
Compute as diferenças simétricas $\Delta(x,x_a) $ \;
\Enqto{$\Delta(x,x_a) \neq \emptyset $}{
	$m^* \leftarrow argmin  \{ f(x \oplus m) : m \in \Delta(x,x_a) \}$ \;
	$ \Delta(x \oplus m^*,x_a) \leftarrow \Delta(x,x_a) - \{ m^* \}$ \;
	$ x \leftarrow x \oplus m^* $ \;
	\Se{$ f(x) < f^* $}{
		$f^* \leftarrow f(x) $ \;
		$x^* \leftarrow x $ \;
	}
}
\caption{Algoritmo \textit{Path-Relinking}}
\end{algorithm}

O \textit{Path-Relinking} pode ser visto com uma estratégia de busca local mais restrita, onde os movimentos aplicados são mais específicos.

De acordo com \cite{Resende05graspwith}, \textit{Path-Relinking} é uma melhoria ao algoritmo básico do GRASP, proporcionando melhoras tanto no tempo quanto na qualidade de solução, e pode ser aplicada de duas formas diferentes:

\begin{itemize}

\item PR é aplicado entre todos os pares de soluções elite. Pode ser feito periodicamente durante as iterações do GRASP ou no final da execução como uma pós-otimização.

\item PR é aplicado como estratégia de intensificação em cada mínimo local obtido logo após a fase de busca local.

\end{itemize}

O algoritmo \ref{algoGraspComPathRelinking} ilustra as duas estratégias embutidas na versão básica do GRASP. O \textit{Path-Relinking} é aplicado entre duas soluções $x$ e $y$: $x$ é um ótimo local obtido na busca local e $y$ é uma solução escolhida aleatoriamente do conjunto de soluções elite. Esse procedimento é aplicado somente a partir da segunda iteração dado que na primeira o conjunto elite está vazio. Esse conjunto é limitado e tem tamanho $MaxElite$.

Ao final de cada iteração o conjunto elite ele é atualizado. Todo ótimo local obtido é candidato a entrar no conjunto. Se ele já tem $MaxElite$ soluções, o candidato só irá entrar se for diferente das soluções presentes e melhor que ao menos uma delas. Esse controle de quem entra e sai do conjunto é implementado pelo procedimento $AtualizaPool$.

Ao final das iterações ocorre a pós-otimização, em que se aplica \textit{Path-Relinking} entre as soluções do conjunto elite, duas as duas. A melhor solução obtida é a resposta do algoritmo.

\begin{algorithm}[H]
\label{algoGraspComPathRelinking}
\SetAlgoLined
\SetKwFunction{GeraSolucaoInicial}{GeraSolucaoInicial}
\SetKwFunction{BuscaLocal}{BuscaLocal}
\SetKwFunction{PathRelinking}{PathRelinking}
\SetKwFunction{AtualizaPool}{AtualizaPool}
\Entrada{MaxIter, MaxElite}
\Saida{Solução $S^{*}$}

$f^{*} \leftarrow \infty $ \;
$Elite \leftarrow \emptyset $ \;
\Para{$i\leftarrow 1$ \Ate $MaxIter$}{
	$S \leftarrow GeraSolucaoInicial() $ \;
	$S \leftarrow BuscaLocal(S) $ \;
	\Se{$ i \geq 2 $}{
		Selecione aleatoriamente $S_{elite} \in Elite $ \;
		$S \leftarrow PathRelinking(S, S_{elite}) $ \;
	}
	\Se{$ f(S) < f^{*} $}{
		$S^{*} \leftarrow S $ \;
		$f^{*} \leftarrow f(S) $ \;
	}
	$AtualizaPool(S, Elite)$ \;
}
$S^* = PosOtimizacao(Elite)$ \;
\caption{Algoritmo GRASP com \textit{Path-Relinking} para intensificação e pós-otimização}
\end{algorithm}

\section{GRASP para o ITC-2007}

Nesta seção será apresentada a implementação do GRASP para o problema de tabela-horário segundo a formulação 3 do ITC-2007. A implementação ficou com uma estrutura similar ao algoritmo \ref{algoGraspComPathRelinking}, com três fases principais em cada iteração: geração da solução inicial, busca local e \textit{path-relinking}.

\subsection{Geração de tabela-horário inicial}

O objetivo da etapa de construção inicial é produzir uma tabela-horário viável, e se possível, com poucas violações das restrições fracas. O GRASP não exige que a solução inicial seja viável, mas foi decidido implementar desta forma para que nas fases seguintes o algoritmo concentre apenas na eliminação das violações das restrições fracas.

Partindo de uma tabela-horário vazia, as aulas são acrescentadas uma a uma até que todas estejam alocadas. A escolha é tanto gulosa (para produzir soluções de boa qualidade) quanto aleatória (para produzir soluções diversificadas).

Com intuito de se conseguir uma solução viável, é adotada uma estratégia de alocar as aulas mais conflitantes primeiro. Poucos horários são viáveis para as disciplinas mais conflitantes, portanto, é melhor alocá-las quando a tabela está mais vazia. Para medir se uma aula é mais conflitante que outra são contados quantos horários (dentre os desocupados) servem para alocar a aula da disciplina. Esta contagem envolve:

\begin{itemize}

\item retirar os horários em o que o professor da disciplina já leciona alguma aula,
\item retirar os horários em que estão alocadas disciplinas do mesmo currículo, e
\item retirar os horários que são indisponíveis para a disciplina segundo a restrição de indisponibilidade.

\end{itemize}

Em cada iteração, a aula mais difícil é escolhida para ser alocada. Existem diferentes combinações de horários e salas para a alocação. Os custos de todas essas combinações são calculados levando-se em conta as penalizações das restrições fracas. As combinações que possuem horários inviáveis são descartadas. Com base no menor e maior custo de adição de um elemento à solução ($c^{min}$ e $c^{max}$) é construída a lista restrita de candidatos (LRC). Estarão na LRC as aulas cujos custos estejam no intervalo \begin{math} [c^{min}, c^{min}+\alpha(c^{max} - c^{min})]\end{math}. Uma aula é escolhida aleatoriamente da LRC e acrescentada à solução.

É possível que em alguns casos, ao escolher uma aula para alocar não haja um horário que mantenha a viabilidade da solução. Para contornar esta situação foi implementado um procedimento denominado "explosão". É uma estratégia que retira da tabela uma aula alocada anteriormente para abrir espaço para a aula que não está sendo possível alocar. A aula retirada volta para o conjunto de aulas não alocadas.

A primeira estratégia de explosão foi escolher o horário que possui menos disciplinas conflitantes e retirar todas elas da tabela. Essa estratégia não foi muito eficaz porque introduziu certa ciclagem no algoritmo, retirando uma aula e alocando outra, mas posteriormente fazendo o inverso, já que o horário escolhido era quase sempre o mesmo.

Uma estratégia que foi mais eficaz foi escolher um horário aleatoriamente, ao invés de selecionar aquele com menos aulas conflitantes. Testes mostraram que essa estratégia se livra melhor do problema de ciclagem.

O algoritmo \ref{solInicialGrasp-ITC2007} ilustra o procedimento de geração de uma tabela-horário inicial. Ele recebe como parâmetro as aulas das disciplinas para serem alocadas na tabela que inicialmente é vazia. Para facilitar a recuperação da aula mais conflitante é criada uma lista de aulas não alocadas. Esta lista é ordenada de forma decrescente pela quantidade de conflitos, portanto a aula na primeira posição da lista é a mais conflitante.

A cada iteração a aula mais conflitante que ainda não foi alocada é selecionada. Em seguida é verificado em quais horários pode ser alocada a aula sem gerar inviabilidades. Se não houver horário disponível ocorre a explosão, portanto, pelo menos em um horário poderá ocorrer a alocação. Os horários disponíveis são combinados com todas as salas, e é feita uma avaliação do custo alocar a aula na respectiva sala e horário. Com base nos custos é construída a lista restrita de candidatos. A aula é então inserida na tabela numa posição escolhida aleatoriamente da LRC. A lista de aulas não alocadas é atualizada e ordenada novamente. Essa ordenação é necessária porque a última aula alocada poderá gerar conflitos com as aulas que ainda serão aloacadas. O procedimento termina quando todas aulas estão alocadas.

\begin{algorithm}[H]
\label{solInicialGrasp-ITC2007}
\SetAlgoLined
\SetKwFunction{GeraSolucaoInicial}{GeraSolucaoInicial}
\SetKwFunction{BuscaLocal}{BuscaLocal}
\SetKwFunction{PathRelinking}{PathRelinking}
\SetKwFunction{OrdenaAulasPorDificuldade}{OrdenaAulasPorDificuldade}
\Entrada{A = \{conjunto de aulas\}, $\alpha$}
\Saida{Tabela-horário T}

$T \leftarrow \emptyset $ \;
$ListaNaoAlocadas \leftarrow GeraListaNaoAlocadas(A) $ \;
$OrdenaAulasPorConflitos(ListaNaoAlocadas) $ \;
\Enqto{$|ListaNaoAlocadas| > 0$}{
	$ a \leftarrow ListaNaoAlocadas[0] $ \;
	$H \leftarrow h | h $ é viável para $ a $ \;
	\Se{$ H = \emptyset $}{
		ExplodeSolucao(T, a) \;
		$H \leftarrow h | h $ é viável para $ a $ \;
	}
	Para todo $ (s, h) \in S \times H, T[s, h] = \emptyset $, computar o custo de alocação $f(a,s,h) $ \;
	$c^{min} \leftarrow min\{f(a,s,h) | (s, h) \in S \times H\}$\;
	$c^{max} \leftarrow max\{f(a,s,h) | (s, h) \in S \times H\}$\;
	$LRC \leftarrow \{ (s,h) \in S \times H | f(a,s,h) \leq c^{min} + \alpha(c^{max} - c^{min}) \} $ \;
	Escolha aleatoriamente $(s',h') \in LRC $ \;
	$T[s',h'] = a $\;
	$RetiraAula(ListaNaoAlocadas, a) $ \;
	$OrdenaAulasPorConflitos(ListaNaoAlocadas) $ \;
}
\caption{Algoritmo construtivo para geração de tabela-horário inicial}
\end{algorithm}

\subsection{Buscal local\label{subsec:abordagens}}

O objetivo da fase de busca local é melhorar a tabela-horário inicial. Para realizar esta intensificação é preciso primeiro definir uma forma de explorar a vizinhança da solução.

Foram implementadas duas estruturas de vizinhança:

\begin{itemize}
\item \textbf{\textit{MOVE}}: Uma aula é movida para uma posição vazia na tabela-horário.
\item \textbf{\textit{SWAP}}: Duas aulas trocam de posição na tabela-horário.
\end{itemize}

Como o GRASP não especifica qual algoritmo irá gerar os vizinhos em busca de soluções melhores, várias estratégias podem ser usadas.

A primeira estratégia implementada neste trabalho é uma das mais simples, conhecida como \textit{Hill Climbing}. A partir de uma solução inicial, em cada iteração um vizinho é gerado. Quando um vizinho com melhor função objetivo é encontrado ele passa a ser a solução atual. O algoritmo implementado termina quando se passa $N$ iterações sem melhora na função objetivo.

Particularmente para o ITC-2007, essa estratégia mostrou-se pouco eficiente, se prendendo facilmente em mínimos locais.

Uma modificação proposta foi fazer a busca em largura, ao invés de em profundidade como é tradicionalmente feita no \textit{Hill Climbing}. Mas a busca em largura é inviável para este problema, já que a quantidade de vizinhos de uma tabela-horário é muito grande. Foi decidido implementar uma versão híbrida. Em cada iteração são gerados $k$ vizinhos e, caso haja melhora, o melhor deles passa a ser a solução atual. Controlando o valor $k$ adequadamente esta versão consegue resultados superiores com uma eficiência parecida à da busca em profundidade. Fazendo $k=1$, tem-se o algoritmo \textit{Hill Climbing} original.

Foi verificado que esta nova versão consegue explorar melhor o espaço de soluções, conseguindo tabelas-horário melhores com menos tempo de execução.

Mas as respostas ainda não estavam satisfatórias para a maioria das instâncias. Foi necessário investir numa estratégia mais rebuscada, que intensifique bem a solução inicial e seja capaz de escapar de mínimos locais. A opção adotada foi usar \textit{Simulated Annealing}\cite{SA}. Essa estratégia de busca é inspirada num processo de metalurgia que aquece um material e resfria de modo controlado visando diminuir seus defeitos.

O algoritmo SA possui três parâmetros principais: temperatura inicial, final e taxa de resfriamento. O algoritmo parte de uma temperatura inicial que vai sendo resfriada até chegar a temperatura final. Em cada temperatura, $N$ vizinhos são gerados. Se o vizinho gerado é melhor que a solução atual, esta é atualizada. Se o vizinho for pior ele é aceito com uma probabilidade igual a $P = e^{\Delta f/ T}$. $\Delta f$ é a difença de valor da função objetivo do vizinho e da solução atual e $T$ é a temperatura atual. Quanto maior for $\Delta f$ e menor a temperatura menores serão as chances de aceitar o vizinho. O comportamento típico do algoritmo é fazer certa diversificação no início quando a temperatura está alta. À medida em que ela decresce poucas pioras vão sendo aceitas e uma determinada região da busca é intensificada.

O algoritmo \ref{algoSA} apresenta o pseudo-código do \textit{Simulated Annealing} para o ITC-2007.

\begin{algorithm}[H]
\label{algoSA}
\SetAlgoLined
\SetKwFunction{GeraSolucaoInicial}{GeraSolucaoInicial}
\SetKwFunction{BuscaLocal}{BuscaLocal}
\SetKwFunction{PathRelinking}{PathRelinking}
\SetKwFunction{AtualizaPool}{AtualizaPool}
\Entrada{Solução S , $t_i$, $t_f$, $\beta$, $N$}
\Saida{Solução $S^{*}$}

$T \leftarrow T_i$ \;
$S^{*} \leftarrow S $ \;
\While{$T > T_f$}{
	\Para{$i \leftarrow 1$ \Ate $N$}{
		$S' \leftarrow GeraVizinho(S^{*}) $ \;
		$\Delta f \leftarrow f(S') - f(S) $ \;
		\Se{$ \Delta f < 0$}{
			$S^{*} \leftarrow S' $ \;
		}\Senao{
			Gere um número aleatório $p$ \;
			\Se{$ p < e^{\Delta f / T} $}{
				$S^{*} \leftarrow S' $ \;
			}
		}
	}
	$T \leftarrow T * \beta$
}
\caption{\textit{Simulated Annealing} para fase de busca local}
\end{algorithm}

Em \cite{CDGS11b}, a mesma estrutura de vizinhança é utilizada, só que a formulação usada é o \textit{track} 2 do ITC-2007. $60\%$ dos vizinhos são gerados com \textit{MOVE}, e os outros $40\%$ são gerados com \textit{MOVE} seguido de um \textit{SWAP}. Foi verificado através de testes que esta estratégia não se adapta tão bem ao \textit{track} 3 do campeonato. Gerando $50\%$ dos vizinhos com \textit{MOVE} e os outros $50\%$ somente com \textit{SWAP} o algoritmo atinge soluções melhores e de forma mais rápida. Uma possível explicação para este comportamento é que sobrepondo duas estruturas de vizinhança, uma estrutura pode atrapalhar a melhora obtida pela outra.

\subsection{Path-relinking}

No algoritmo implementado o \textit{Path-relinking} é aplicado entre a solução obtida na busca local e uma solução do conjunto elite. Como pode ser visto em \cite{Resende05graspwith}, o caminho percorrido entre as duas soluções pode ser feito de diversas maneiras. As duas principais são:

\begin{itemize}
\item \textbf{Religamento direto}: PR parte da solução pior em direção à melhor.
\item \textbf{Religamento inverso}: PR é aplicado partindo da melhor solução em direção à pior.
\end{itemize}

Pode se optar por construir os dois caminhos, com a desvantagem que o tempo de execução é o dobro. \cite{Resende05graspwith} cita que no caso de fazer a opção por somente uma das trajetórias, as melhores soluções geralmente são encontradas utilizando religamento inverso. A explicação para isso é que boas soluções tendem a estar próximas à solução mais promissora. Sendo assim, o GRASP implementado aplica \textit{Path-relinking} usando uma solução elite como a inicial e a solução obtida na busca local é a alvo.

Tanto no \textit{Path-relinking} quanto na busca local, movimentos que introduzem inviabilidades na solução são descartados. Assim a viabilidade da solução obtida na construção inicial fica garantida.


\begin{algorithm}[H]
\label{algoBase}
\SetAlgoLined
\SetKwFunction{GeraSolucaoInicial}{GeraSolucaoInicial}
\SetKwFunction{BuscaLocal}{BuscaLocal}
\SetKwFunction{PathRelinking}{PathRelinking}
\SetKwFunction{AtualizaPool}{AtualizaPool}
\Entrada{Instância p, MaxIter, TamPool}
\Saida{Solução $S^{*}$}

$f^{*} \leftarrow \infty $ \;
$Pool \leftarrow \phi $ \;
\Para{$i\leftarrow 1$ \Ate $MaxIter$}{
	$S \leftarrow GeraSolucaoInicial() $ \;
	$S \leftarrow BuscaLocal(S) $ \;
	\Se{$ i > TamPool $}{
		Selecione aleatoriamente $S_{elite} \in Pool $ \;
		$S \leftarrow PathRelinking(S, S_{elite}) $ \;
	}
	\Se{$ f(S) < f^{*} $}{
		$S^{*} \leftarrow S $ \;
		$f^{*} \leftarrow f(S) $ \;
	}
	$AtualizaPool(S, Pool)$ \;
}
\caption{Algoritmo GRASP}
\end{algorithm}


\chapter{Resultados Computacionais\label{cap:resultados}}

\vfill{}
\begin{flushright}{}``\emph{Nada se cria, nada se perde, tudo se
transforma.}''\\
{\small Lavousier}\end{flushright}{\small \par}
\vfill{}

Neste capítulo é apresentado os resultados computacionais
...
\newpage

\section{Descrição das instâncias utilizadas}

As instâncias utilizadas foram as mesmas submetidas aos competidores do ITC-2007.
São 21 instâncias ao todo, com grau de dificuldade variado. A organização garante que existe solução viável para todas as instâncias, fato que foi comprovado nos testes. Mas nada foi informado sobre a quantidade de violações fracas em cada instância. Em \cite{itc2007} podem ser obtidas todas as instâncias.

Na tabela \ref{tab:instancias} são apresentados os dados mais relevantes de cada instância. A quantidade de horários de aula numa semana não varia muito de instância para instância. A coluna conflitos conta a quantidade de pares de aula que não podem ser alocadas no mesmo horário (mesma disciplina, mesmo currículo ou mesmo professor) dividido pelo total de pares distintos de aula. A disponibilidade mede percentualmente a quantidade de horários que são disponíveis para as aulas, levando-se em conta as restrições de indisponibilidade que são informadas no arquivo de entrada.

A quantidade de currículos e disciplinas tem grande impacto no tempo de execução do algoritmo, pois são mais aulas para fazer a contagem total de violações. A quantidade de conflitos e disponibilidade influencia na dificuldade de encontrar uma solução viável, pois quanto mais conflitos e menos disponibilidade, menos horários existirão para alocar aula sem violar as restrições fortes. Além de dificultar a viabilidade no momento de geração da solução inicial, os conflitos e as disponibilidades dificultam a exploração da vizinhança na busca local, dado que muitas trocas acabam sendo descartadas por introduzirem violações das restrições fortes.

\begin{center}
\begin{table}[!htb]
\begin{tabular}{|c|c|c|c|p{1.8cm}|c||c|p{1.8cm}|}\hline
{\bf Instância} & {\bf Currículos} & {\bf Salas} & {\bf Disciplinas} &{\bf Horários por dia}&{\bf Dias}&{\bf Conflitos} & {\bf Disponibi-lidade}\\\hline
comp01 & 14 & 6 & 30 & 6 & 5 & 13.2 & 93.1 \\ 
comp02 & 70 & 16 & 82 & 5 & 5 & 7.97 & 76.9 \\ 
comp03 & 68 & 16 & 72 & 5 & 5 & 8.17 & 78.4 \\ 
comp04 & 57 & 18 & 79 & 5 & 5 & 5.42 & 81.9 \\ 
comp05 & 139 & 9 & 54 & 6 & 6 & 21.7 & 59.6 \\ 
comp06 & 70 & 18 & 108 & 5 & 5 & 5.24 & 78.3 \\ 
comp07 & 77 & 20 & 131 & 5 & 5 & 4.48 & 80.8 \\ 
comp08 & 61 & 18 & 86 & 5 & 5 & 4.52 & 81.7 \\ 
comp09 & 75 & 18 & 76 & 5 & 5 & 6.64 & 81 \\ 
comp10 & 67 & 18 & 115 & 5 & 5 & 5.3 & 77.4 \\ 
comp11 & 13 & 5 & 30 & 9 & 5 & 13.8 & 94.2 \\ 
comp12 & 150 & 11 & 88 & 6 & 6 & 13.9 & 57 \\ 
comp13 & 66 & 19 & 82 & 5 & 5 & 5.16 & 79.6 \\ 
comp14 & 60 & 17 & 85 & 5 & 5 & 6.87 & 75 \\ 
comp15 & 68 & 16 & 72 & 5 & 5 & 8.17 & 78.4 \\ 
comp16 & 71 & 20 & 108 & 5 & 5 & 5.12 & 81.5 \\ 
comp17 & 70 & 17 & 99 & 5 & 5 & 5.49 & 79.2 \\ 
comp18 & 52 & 9 & 47 & 6 & 6 & 13.3 & 64.6 \\ 
comp19 & 66 & 16 & 74 & 5 & 5 & 7.45 & 76.4 \\ 
comp20 & 78 & 19 & 121 & 5 & 5 & 5.06 & 78.7 \\ 
comp21 & 78 & 18 & 94 & 5 & 5 & 6.09 & 82.4 \\
\hline
\end{tabular}
\caption{Tabela com informações sobre cada instância do ITC-2007}
\label{tab:instancias}
\end{table}
\end{center}

\section{Detalhes de implementação}

Todas as implementações foram feitas na linguagem C. A tabela-horário é representada com uma matriz. As linhas representam as salas e as colunas representam os horários de todos os dias. As aulas são representadas por números inteiros. Cada aula da disciplina é representada por um número diferente. Se a primeira disciplina da instância possui 5 aulas semanais, então elas serão representadas com os números 1, 2, 3, 4 e 5. Uma segunda disciplina com 3 aulas será representada na tabela com os números 6, 7 e 8, e assim por diante. Horários vagos são representados com números maiores que o total de aulas presentes na instância.

A tabela \ref{tab:solucao_toy_codificada} é a mesma representação da tabela-horário \ref{tab:solucao_toy} usando a codificação com números inteiros. São 3 aulas para \textit{SecCosC}, 3 para \textit{ArcTec}, 5 para \textit{TecCos} e 5 para \textit{Geotec}, totalizando 16 aulas que estão destacadas em negrito. Todas as demais são horários vazios.

\begin{center}
\begin{table}[!htb]
\begin{tabular}{|c|c|c|c|c||c|c|c|c||c|c|c|c||c|c|c|c||c|c|c|c|}\hline
 & \multicolumn{4}{|c||}{Dia 0} & \multicolumn{4}{|c||}{Dia 1}& \multicolumn{4}{|c||}{Dia 2}& \multicolumn{4}{|c||}{Dia 3}&  \multicolumn{4}{|c|}{Dia 4}\\ \hline
 & 0 & 1 & 2 & 3 & 0 & 1 & 2 & 3 & 0 & 1 & 2 & 3 & 0 & 1 & 2 & 3 & 0 & 1 & 2 & 3 \\ \hline
rA & 18 & {\bf 12} & 17 & 19 & {\bf 13} & 20 & {\bf 14} & {\bf 15} & 21 & 22 & 23 & 24 & 25 & 26 & 27 & 28 & 29 & 30 & 31 & {\bf 16} \\ \hline
rB & 32 & 33 & {\bf 4} & 34 & {\bf 5} & 35 & 36 & 37 & 38 & 39 & 40 & 41 & 42 & 43 & 44 & 45 & 46 & 47 & 48 & 49 \\ \hline
rC & 50 & {\bf 7} & 51 & 52 & 53 & {\bf 8} & {\bf 1} & 54 & 55 & 56 & {\bf 2} & {\bf 9} & {\bf 3} & 57 & 58 & 59 & {\bf 10} & 60 & {\bf 11} & {\bf 6} \\ \hline
\end{tabular}
\caption{Tabela-horário para a instância \textit{Toy} codificando as aulas com números inteiros}
\label{tab:solucao_toy_codificada}
\end{table}
\end{center}

Algumas matrizes auxiliares foram utilizadas para extrair algumas informações de forma mais rápida. Algumas delas são estáticas pois dependem apenas das informações presentes no arquivo de entrada. Outras são dinâmicas para refletir o estado atual da tabela-horário que está sendo considerada.

São duas matrizes estáticas. Considere $N$ o número total de aulas na instância e $H$ o total de horários, que é a quantidade de dias multiplicada pela quantidade de períodos de aula em um dia.

A primeira matriz, chamada de $AA$, possui dimensão $N \times N$. Ela é utilizada para descobrir de forma rápida se duas aulas tem conflito entre si, ou se pertencem a mesma disciplina. Dadas duas aulas $a_1$ e $a_2$, faz se a seguinte convenção:

\begin{itemize}
\item $AA[a_1][a_2] = 2$: as duas aulas são da mesma disciplina;
\item $AA[a_1][a_2] = 1$: as duas aulas possuem conflitos entre si, seja por estarem num mesmo currículo ou por serem lecionadas pelo mesmo professor; e
\item $AA[a_1][a_2] = 0$: não há conflitos entre as aulas e elas não pertencem a mesma disciplina;
\end{itemize}

A segunda matriz estática, chamada de $AI$, possui dimensão $N \times H$. Ela é utilizada para verificar quais horários são disponíveis para as aulas segundo as restrições de indisponibilidade que são informadas no arquivo de entrada. Dois valores são possíveis nesta matriz:

\begin{itemize}
\item $AI[a][h] = 1$: a aula $a$ é indisponível no horário $h$; e
\item $AI[a][h] = 0$: a aula $a$ pode ser alocada no horário $h$.
\end{itemize}

É preciso ressaltar que somente $AI[a][h] = 0$ não garante a possibilidade de $a$ ser alocada no horário $h$. Durante a execução do algoritmo é necessário avaliar a tabela-horário em questão para saber se existe alguma sala desocupada no horário $h$ e se nenhuma aula já alocada no horário é conflitante com $a$.

As matrizes dinâmicas refletem o estado da tabela-horário que está sendo considerada. O objetivo principal destas tabelas é fazer a contagem das violações fracas de forma mais eficiente. Considere $C$ o total de currículos, $DC$ o total de disciplinas, $D$ a quantidade de dias, $P$ a quantidade de períodos de aula num dia e $S$ o total de salas.

A primeira matriz é $DiscDias$ com dimensão $DC \times D$. Para uma dada disciplina $disc$ e um dia $d$, $DiscDias[disc][dia]$ retorna a quantidade de de aulas da disciplina $disc$ no dia $d$. Com esta matriz é possível contar mais rapidamente em quantos dias há aulas de uma certa disciplina, facilitando o cálculo da contagem das violações de dias mínimos de trabalho.

A segunda matriz, $DiscSalas$, tem dimensão $DC \times S$. $DiscSalas[disc][s]$ retorna a quantidade de aulas da disciplina $disc$ na sala $s$ durante a semana. Analogamente esta matriz tem por objetivo verificar quantas salas estão sendo ocupadas pela disciplina, facilitando a contagem das violações referentes à estabilidade de sala.

A terceira matriz, $CurrDiasPeriodos$, é tridimensional com tamanho $C \times D \times P$. $CurrDiasPeriodos[c][d][p]$ retorna a quantidade de aulas do currículo $c$ alocadas no dia $d$ e horário $p$. Ela é usada para verificar se um currículo está com aulas isoladas. Se um currículo $c$ possui alguma aula no dia $d$ e horário $p$, mas $CurrDiasPeriodos[c][d][p-1] = 0$ e $CurrDiasPeriodos[c][d][p+1] = 0$ então o currículo $c$ não tem nenhuma aula nem no período anterior nem no próximo, o que gera uma violação de aulas isoladas.

As matrizes dinâmicas são atualizadas quando um novo vizinho é gerado. Supondo que a aula $a$ da disciplina $disc$ foi movida da posição $(s1, d1, p1)$ para a posição $(s2, d2, p2)$  e que ela pertence aos currículos $C_a$, as seguintes operações serão feitas:

\begin{equation}
\begin{split}
DiscDias[disc][d1] = DiscDias[disc][d1] - 1 \\
DiscDias[disc][d2] = DiscDias[disc][d2] + 1 \\
DiscSalas[disc][s1] = DiscSalas[disc][s1] - 1 \\
DiscSalas[disc][s2] = DiscSalas[disc][s2] + 1 \\
CurrDiasPeriodos[c][d1][p1] = CurrDiasPeriodos[c][d1][p1] - 1, \forall c \in C_a \\
CurrDiasPeriodos[c][d2][p2] = CurrDiasPeriodos[c][d2][p2] + 1, \forall c \in C_a \\
\end{split}
\end{equation}

Além das matrizes auxiliares, outro detalhe importante é a geração e avaliação dos vizinhos. Num primeiro momento, os vizinhos eram gerados e a função objetivo era chamada para avaliar este vizinho. Dado que \textit{MOVE} e \textit{SWAP} alteram apenas duas posições, é mais eficiente verificar o efeito das trocas localmente já que o restante da tabela permanece inalterado. Assim, as funções de geração de vizinhos retornam, além das posições de troca, um $\Delta f$. Se $\Delta f$ é menor que zero, então significa que o vizinho terá uma função objetivo melhor.

Para avaliar a melhora desta modificação foram criados dois programas para gerar uma tabela-horário inicial aleatória, e em seguida gerar e avaliar 100000 vizinhos desta tabela. No primeiro programa a avaliação era feita levando em consideração toda a tabela. No segundo a avaliação era apenas local. Usando a instância \textit{comp01} como parâmetro, o primeiro executou numa média de $44.996$ segundos, enquanto o segundo em $4.242$ segundos. O \textit{speedup} aproximado foi portanto de $10 \times$. Já usando a instância \textit{comp12} que é uma instância maior, o primeiro executou numa média de $467.603$ segundos, enquanto o segundo em $19.803$ segundos. Nesta instância maior o \textit{speedup} foi superior a $23 \times$.



\section{Escolha dos parâmetros}

O algoritmo GRASP possui dois parâmetros: número máximo de iterações \textit{MaxIter} e o valor $\alpha$ que regula a forma de construção da solução inicial. Como foi implementado \textit{Path-relinking}, um terceiro parâmetro, \textit{MaxElite}, foi adicionado para limitar o tamanho do conjunto de soluções elite.

Quanto mais iterações, mais soluções o algoritmo pode explorar. Foi escolhido limitar a quantidade de iterações em 200. Mas como o campeonato exige que o algoritmo execute em aproximadamente 10 minutos, não é possível executar essa quantidade de iterações. O número máximo de soluções elite foi fixado em 20.

O parâmetro $\alpha$ é mais delicado. Se o seu valor for muito próximo de zero, o algoritmo de construção inicial tem comportamento mais guloso, produzindo soluções de boa qualidade porém pouco diversificadas. Se $\alpha$ é mais próximo de um, as soluções são mais diversificadas mas com a desvantagem que elas tem um valor alto de função objetivo. Foram testados diversos valores no intervalo $0.01 < \alpha < 0.5$. Foi comprovado que quanto menor o valor de $\alpha$, melhor a qualidade da solução, mas ainda longe do que é possível alcançar com a busca local. Foi decidido usar $\alpha = 0.15$, por produzir certa diversificação nas soluções iniciais e manter uma boa qualidade.

Os demais parâmetros são específicos das buscas locais. O algoritmo \textit{Hill Climbing} possui o parâmetro $N$, que limita a quantidade máxima de iterações sem melhora na função objetivo. Um valor grande de $N$ permite maior exploração dos vizinhos, mas consome maior tempo de execução. Como a idéia do GRASP é explorar soluções diferentes, $N$ foi fixado em 10000. Experimentalmente esse valor permite explorar bem a solução inicial sem se prender muito tempo num mínimo local. Um segundo parâmetro introduzido no algoritmo foi $k$, que fornece a quantidade de vizinhos que serão gerados por iteração. Foi verificado que com $k=10$ o algoritmo produz boas soluções e mantém um desempenho parecido com a versão original em que era gerado apenas um vizinho. Valores maiores de $k$ tornam o algoritmo lento e não há ganho justificável na qualidade das soluções.

O algoritmo \textit{Simulated Annealing} já é mais complicado de se calibrar. Foram escolhidos parâmetros que permitissem certa diversificação no início da busca e que fizesse intensificação no final do processo. Como o algoritmo de solução inicial já fornece uma resposta com qualidade razoável, a temperatura inicial não precisa ser muito alta. Foi observado nos testes que usar temperaturas altas com uma solução boa acaba piorando muito a solução, e só volta a melhorar quando o resfriamento está bem avançado. Foi observado também que, particularmente para as instâncias do ITC-2007, quando o algoritmo fica com uma temperatura abaixo de 0.01 poucas melhores são conseguidas.

Com base nestas observações foram escolhidos os seguintes parâmetros: $T_i = 1.5, T_f = 0.005, \beta = 0.999$. Um valor de $\beta$ um pouco maior poderia ser utilizado para fazer um resfriamento mais lento e explorar mais o espaço de busca, mas devido ao limitante de tempo foi decidido manter esse valor. Em cada temperatura são gerados $N = 500$ vizinhos.

Como explicado na subseção \ref{subsec:abordagens}, os vizinhos em todas as buscas locais são gerados somente com \textit{MOVE} ou somente com \textit{SWAP}. Todas as estrututuras têm igual probabilidade de ocorrer.

\section{Análise dos resultados}

Todos os algoritmos descritos neste trabalho foram implementados na linguagem C, compilados com GCC 4.1.2 e testados em máquina Linux com a distribuição Fedora Core 8, com processador Intel quad-core 2.4 GHz e 2 Gb de memória RAM.

Os organizadores do campeonato forneceram um programa executável para fazer um \textit{benchmark} na máquina de testes dos competidores. O objetivo desse programa é informar um tempo de execução que seria equivalente nas máquinas do campeonato. Rodando esse programa na máquina de teste foi estipulado um tempo de execução de 324 segundos.

Foi necessário adicionar nos algoritmos o critério de parada pelo tempo de execução, pois nas versões apresentadas o único critério era o número máximo de iterações {\it{MaxIter}}.

A tabela \ref{tab:resultados_gerais} lista as melhores respostas encontradas para cada instância do ITC-2007. Os valores informados se referem apenas às violações das restrições fracas, já que todas as soluções são viáveis. Assim como foi feito no ITC-2007, cada algoritmo foi executado 10 vezes com diferentes \textit{seeds} para geração de números aleatórios.

Foram testados três versões do algoritmo, variando a busca local:

\begin{itemize}
\item {\bf GHC1}: Busca local {\it{Hill Climbing}} com $k=1$. (Somente um vizinho é gerado por iteração).
\item {\bf GHC2}: Busca local {\it{Hill Climbing}} com $k=10$. (10 vizinhos são gerados por iteração).
\item {\bf GSA}: Busca local {\it{Simulated Annealing}}.
\end{itemize}



\begin{center}
\begin{table}[htbf]
\begin{tabular}{|l|c|c|c|c|}
\hline
Instância & GHC1 & GHC2 & GSA & GRASP \\ \hline
comp01 & 5 & 15 & \textbf{6} & \textbf{6} \\
comp02 & 24 & 234 & \textbf{116} & 131 \\
comp03 & 66 & 233 & \textbf{116} & 141 \\
comp04 & 35 & 137 & \textbf{76} & 78 \\
comp05 & 290 & 818 & \textbf{429} & 552 \\
comp06 & 27 & 215 & 132 & \textbf{123} \\
comp07 & 6 & 205 & \textbf{99} & 120 \\
comp08 & 37 & 169 & \textbf{84} & 87 \\
comp09 & 96 & 229 & \textbf{137} & 164 \\
comp10 & 4 & 183 & \textbf{67} & 78 \\
comp11 & 0 & 13 & \textbf{0} & \textbf{0} \\ \hline
\end{tabular}
\medskip
\begin{tabular}{|l|c|c|c|c|}
\hline
Instância & GHC1 & GHC2 & GSA & GRASP \\ \hline
comp12 & 300 & 544 & \textbf{407} & 517 \\
comp13 & 59 & 206 & \textbf{106} & 120 \\
comp14 & 51 & 173 & \textbf{90} & 98 \\
comp15 & 66 & 225 & \textbf{120} & 138 \\
comp16 & 18 & 198 & \textbf{91} & 104 \\
comp17 & 56 & 206 & \textbf{122} & 156 \\
comp18 & 62 & 153 & 133 & \textbf{115} \\
comp19 & 57 & 207 & \textbf{111} & 139 \\
comp20 & 4 & 257 & \textbf{130} & 149 \\
comp21 & 76 & 276 & \textbf{151} & 188 \\
 &  &  &  &   \\ \hline
\end{tabular}
\caption{Resultados computacionais - Melhores respostas obtidas pelos algoritmos GRASP-HC, GRASP-SA, etc}
\label{tab:resultados_gerais}
\end{table}
\end{center}

Nas tabelas \ref{tab:solucoes_itc2007_1} e \ref{tab:solucoes_itc2007_2} podem ser vistos os resultados obtidos pelos competidores. A competição foi dividida em duas fases. A primeira fase durou aproximadamente 6 meses. Os competidores receberam 7 instâncias inicialmente e mais 7 faltando duas semanas para o encerramento da fase. Eles submeteram os algoritmos e as melhores respostas encontradas para cada instância. A tabela \ref{tab:solucoes_itc2007_1} lista os resultados desta primeira fase.

Os cinco melhores algoritmos foram rodados com mais 7 instâncias "ocultas". A tabela \ref{tab:solucoes_itc2007_2} lista os resultados dos finalistas com estas instâncias. Os resultados da primeira fase foram obtidos sem direitos de publicação dos nomes dos não-finalistas, por isso somente a coluna dos 5 melhores estão identificadas.

Em cada tabela foi adicionada uma coluna com os resultados pelo melhor algoritmo implementado neste trabalho, o GSA. Pode-se notar que para os 17 competidores iniciais, ele ficou fora dos 5 primeiros apenas para uma instância. A melhor resposta foi obtida para 2 instâncias. Considerando as últimas 7 instâncias, GSA conseguiu ser superior à 2 finalistas.

\begin{landscape}
\begin{center}
\begin{table}[htbf]
{\small
\begin{tabular}{|l|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|}
\hline
Instância & Atzuna &  &  & Clark & & & & Geiger & Lu & & & & & & Muller & & \\ \hline
comp01 & 5 &	30 &	9 &	10 &	18 &	943 &	31 &	5 &	5 &	112 &	61 &	5 &	97 &	23 &	5 &	114 &	6 \\ 
comp02 & 55 &	252 &	154 &	83 &	206 &	128034 &218 &	108 &	34 &	485 &	1976 &	127 &	393 &	86 &	43 &	295 &	185 \\
comp03 & 91 &	249 &	120 &	106 &	235 &	55403 &	189 &	115 &	70 &	433 &	739 &	141 &	314 &	121 &	72 &	229 &	184 \\
comp04 & 38 &	226 &	66 &	59 &	156 &	25333 &	145 &	67 &	38 &	405 &	713 &	72 &	283 &	63 &	35 &	199 &	158 \\
comp05 & 325 &	522 &	750 &	362 &	627 &	79234 &	573 &	408 &	298 &	1096 &	28249 &	10497 &	672 &	851 &	298 &	723 &	421 \\
comp06 & 69 &	302 &	126 &	113 &	236 &	346845 &247 &	94 &	47 &	520 &	3831 &	96 &	464 &	115 &	41 &	278 &	298 \\
comp07 & 45 &	353 &	113 &	95 &	229 &	396343 &327 &	56 &	19 &	643 &	7470 &	103 &	577 &	92 &	14 &	291 &	398 \\
comp08 & 42 &	224 &	87 &	73 &	163 &	64435 &	163 &	75 &	43 &	412 &	833 &	75 &	373 &	71 &	39 &	204 &	211 \\
comp09 & 109 &	275 &	162 &	130 &	260 &	44943 &	220 &	153 &	102 &	494 &	776 &	159 &	412 &	177 &	103 &	273 &	232 \\
comp10 & 32 &	311 &	97 &	67 &	215 &	365453 &262 &	66 &	16 &	498 &	1731 &	81 &	464 &	60 &	9 &	250 &	292 \\
comp11 & 0 &	13 &	0 &	1 &	6 &	470 &	8 &	0 &	0 &	104 &	56 &	0 &	99 &	5 &	0 &	26 &	0 \\
comp12 & 344 &	577 &	510 &	383 &	676 &	204365 &594 &	430 &	320 &	1276 &	1902 &	629 &	770 &	828 &	331 &	818 &	458 \\
comp13 & 75 &	257 &	89 &	105 &	213 &	56547 &	206 &	101 &	65 &	460 &	779 &	112 &	408 &	112 &	66 &	214 &	228 \\
comp14 & 61 &	221 &	114 &	82 &	206 &	84386 &	183 &	88 &	52 &	393 &	756 &	88 &	487 &	96 &	53 &	239 &	175 \\ \hline
Média & 92,21 &	272,29 &171,21 &119,21 &246,14 &132338,14 &240,43 &126,14 &	79,21 &	523,64 &3562,29 &870,36 &415,21 &192,86 &79,21 &296,64 &231,86 \\ \hline
\end{tabular}
}
\caption{Resultados primeira fase}
\label{tab:solucoes_itc2007_1}
\end{table}
\end{center}

\begin{center}
\begin{table}[htbf]
{\small
\begin{tabular}{|l|c|c|c|c|c|c|}
\hline
Instância & Atzuna & Clark & Geiger & Lu & Muller & GSA \\ \hline
comp15 & & & & & & \\ 
comp16 & & & & & & \\ 
comp17 & & & & & & \\ 
comp18 & & & & & & \\ 
comp19 & & & & & & \\ 
comp20 & & & & & & \\ 
comp21 & & & & & & \\  \hline
Média & 92,21 &	272,29 &171,21 &119,21 &246,14 &132338,14  \\ \hline
\end{tabular}
}
\caption{Resultados da segunda fase}
\label{tab:solucoes_itc2007_2}
\end{table}
\end{center}
\end{landscape}


\chapter{Conclusões e trabalhos futuros\label{cap:conclusao}}

\vfill{}
\begin{flushright}{}``\emph{Nada se cria, nada se perde, tudo se
transforma.}''\\
{\small Lavousier}\end{flushright}{\small \par}
\vfill{}

Neste capítulo é apresentado as conclusões e alguns trabalhos futuros
...
\newpage


\section{Conclusões}

{\bf Alguns itens interessantes para a conclusão de um projeto de graduação}

Qual foi o resultado do seu trabalho? melhora na área, testes positivos ou negativos?
Você acha que o mecanismo gerado produziu resultados interessantes?
Quais os problemas que você encontrou na elaboração do projeto?
E na implementação do protótipo?
Que conclusão você tirou das ferramentas utilizadas? (heurísticas, prolog, ALE, banco de dados).
Em que outras áreas você julga que este trabalho seria interessante de ser aplicado?
Que tipo de continuidade você daria a este trabalho?
Que tipo de conhecimento foi necessário para este projeto de graduação?
Para que serviu este trabalho na sua formação?


\bibliographystyle{abnt-alf}
\bibliography{monografia}


\anexo


\chapter{Código-fonte dos algoritmos}

Todos os códigos-fontes, além de arquivos auxiliares necessários para execução do programa podem ser obtidos no repositório \textit{github}, através do link: \textit{https://github.com/walacesrocha/Timetabling}. O projeto pode ser baixado como arquivo \textit{zip} ou ser obtido através do comando \texttt{git clone git://github.com/walacesrocha/Timetabling.git}.

O projeto está estruturado na seguinte árvore de diretórios:

\begin{itemize}
\item \textbf{ /} : arquivos .c e .h com implementação dos algoritmos, além do Makefile para auxiliar a compilação.
\item \textbf{ /instancias} : contém as 21 instâncias usadas no ITC-2007.
\item \textbf{ /solucoes} : arquivos com as melhores respostas para cada instância.
\item \textbf{ /validator} : ferramenta fornecida pelo ITC-2007 para validação das respostas. Está implementada em C++.
\item \textbf{ /benchmark\_machine} : ferramenta fornecida pelo ITC-2007 para ajustar o tempo de teste dos algoritmos.
\end{itemize}

As instâncias oficiais e o validador também podem ser obtidas no site \cite{itc2007}.

Para compilar os códigos fontes basta executar no diretório raiz:
\begin{verbatim}
$ make
\end{verbatim}

Todos os códigos-fonte serão compilados e um executável será criado com o nome \texttt{grasp}. Para executar o programa, o caminho para uma instância deve ser informado:

\begin{verbatim}
$ ./grasp instancias/comp01.ctt
\end{verbatim}

O programa possui diversos parâmetros opcionais. Caso não sejam informados serão usados os valores padrão de acordo com a tabela \ref{tab:parametros}. Os parâmetros são informados usando a sintaxe \texttt{parametro=valor}. Exemplo:

\begin{verbatim}
$ ./grasp instancias/comp01.ctt maxIter=50 alfa=0.20 seed=1
\end{verbatim}


O Algortimo exibe ao final a quantidade de violações fortes e fracas, além da resposta formatada no padrão do ITC-2007, que foi exemplificada na seção \ref{sec:formulacao}.

\begin{center}
\begin{table}[!htb]
\begin{tabular}{|c|c|c|}\hline
{\bf Parâmetro} & {\bf Descrição} & {\bf Valor padrão} \\ \hline
maxIter & Número máximo de iteracoes do Grasp & 200 \\ \hline
 alfa & Valor de \textit{threshold} da LRC & 0.15 \\ \hline
 bl & Busca local: hc para \textit{Hill Climbing}, sa para \textit{Simulated Annealing} & hc \\ \hline
 n & Número máximo de iteracoes sem melhora em \textit{Hill Climbing} & 10000 \\ \hline
 k & Quantidade de vizinhos que são gerados por iteração na busca \textit{Hill Climbing} & 10 \\ \hline
 ti & Temperatura inicial no SA & 3 \\ \hline
 tf & Temperatura final no SA & 0.001 \\ \hline
 beta & Taxa de resfriamento no SA & 0.995 \\ \hline
 seed & Seed de geração de números aleatorios & 0 \\ \hline
 time & Tempo limite de execução. Valor negativo indica tempo ilimitado & -1 \\ \hline
\end{tabular}
\caption{Parâmetros do GRASP e seus valores padrão}
\label{tab:parametros}
\end{table}
\end{center}

\end{document}
