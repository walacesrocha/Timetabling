%% LyX 1.3 created this file.  For more info, see http://www.lyx.org/.
%% Do not edit unless you really know what you are doing.
\documentclass[brazil,ruledheader]{abnt}
\usepackage[T1]{fontenc}
\usepackage[latin1]{inputenc}
%\usepackage[vlined,boxruled,linesnumbered,portuguese]{algorithm2e}
\usepackage[ruled,longend,lined,linesnumbered,portuguese]{algorithm2e}
% Escrita dos algoritmos
\usepackage{amssymb,amsmath}



\makeatletter
\usepackage{babel}
\makeatother
\begin{document}

\autor{Walace de Souza Rocha}


\titulo{Algoritmo GRASP para o Problema de Tabela-horário de Universidades}


\orientador{Maria Claudia Silva Boeres}


\coorientador{Maria Cristina Rangel}


\comentario{Dissertação apresentada para obtenção do Grau de Bacharel em Ciência
da Computação pela Universidade Federal do Espírito Santo.}


\instituicao{Departamento de Informática \par Centro Tecnológico\par Universidade
Federal do Espírito Santo}


\local{Vitória - ES, Brasil}


\data{28 de Fevereiro de 2013}

\capa

\folhaderosto

\begin{folhadeaprovacao}
Dissertação de Projeto Final de Graduação sob o título \textit{``\ABNTtitulodata''},
defendida por \ABNTautordata~e aprovada em \ABNTdatadata, em Vitória,
Estado do Espírito Santo, pela banca examinadora constituída pelos
professores: \setlength{\ABNTsignthickness}{0.4pt}

\assinatura{Profa. Dr. Maria Claudia Silva Boeres\\ Orientadora}
\assinatura{Profa. Dr. Maria Cristina Rangel\\ Co-orientadora}
\assinatura{Prof. Dr. Fulano de Tal\\ Universidade Federal do Espírito Santo}
\end{folhadeaprovacao}
\begin{resumo}
Escreva aqui o texto do seu resumo.
\end{resumo}
\begin{abstract}
Write here the English version of your {}``Resumo''.
\end{abstract}

\chapter*{Dedicatória}

Dedico este trabalho a ...


\chapter*{Agradecimentos}

Agradeço a ...

\tableofcontents{}\listoffigures



\listoftables

\listofalgorithms


\chapter{Introdução\label{cap:introducao}}

\vfill{}
\vfill{}

Neste capítulo são apresentados o objetivo desta dissertação e a estrutura
da mesma.
\newpage

\section{Apresentação do problema}

O problema de tabela-horário consiste em alocar um conjunto de aulas em um número pré-determinado de horários, satisfazendo diversas restrições envolvendo professores, alunos e o espaço físico disponível. A solução manual deste problema não é uma tarefa trivial e as instituições de ensino precisam resolvê-lo anualmente ou semestralmente. Nem sempre a alocação manual é satisfatória, por exemplo, quando um aluno não consegue matricular em duas disciplinas porque elas são alocadas no mesmo horário.

Por esta razão, atenção especial tem sido dada a solução automática de tabela-horário. Nos últimos cinquenta anos, começando com \cite{gotlieb62}, este problema ganhou grande destaque na área de otimização combinatória, tendo diversos trabalhos publicados.

\section{Motivação para o problema}

O problema de tabela-horário está entre os mais difíceis da área de otimização combinatória. Em \cite{Schaerf95asurvey} pode ser visto que ele é classificado como NP-completo. Assim, a solução exata só pode ser garantida para instâncias bem pequenas, que não correspondem às instâncias reais da maioria das instituições de ensino.

Existe uma necessidade de propor algoritmos cada vez mais eficientes que produzam tabelas-horário satisfatórias em um tempo viável, independente do tamanho da instância. Devido à complexidade do problema, métodos exaustivos são descartados. Diferentes meta-heurísticas tem sido aplicadas devido ao fato de serem relativamente simples de implementar e produzirem bons resultados. Dentre as meta-heurísticas que já foram aplicadas ao problema, existe um esforço em aplicar melhorias para conseguir melhores resultados. Há algumas meta-heurísticas que ainda não foram exploradas no problema, o que deixa uma incógnita quanto à sua eficiência.

\section{Objetivos deste trabalho}

O objetivo principal deste trabalho é resolver o problema de tabela-horário de universidades usando a meta-heurística GRASP (\textit{Greedy Randomized Adaptive Search Procedures}). Pelo fato de existirem diversas formulações para o problema, será escolhida uma que tem sido bastante utilizada na área: a que é proposta no ITC-2007 (\textit{International Timetabling Competition - 2007}) \cite{itc2007}. A razão principal desta escolha é facilitar a comparação dos resultados com outros algoritmos propostos na literatura.

Para atingir este objetivo será necessário estudar a formulação do ITC-2007 e propor uma implementação eficiente dos dados. Além de aplicar o GRASP para o problema, pretende-se implementar algumas melhorias que já foram propostas na literatura e que visam melhorar a versão básica do algoritmo.

Vale ressaltar que o ITC-2007 dividiu o campeonato em três \textit{tracks}. Cada \textit{track} possui uma formulação específica e seu próprio conjunto de instâncias. O \textit{track} 1 é uma formulação específica para aplicação de exames finais. Os \textit{tracks} 2 e 3 tratam a alocação semanal das aulas de uma universidade. A diferença básica é que o \textit{track} 2, chamado de \textit{post enrolment} (pós matrícula) trata o problema considerando os dados de matrícula dos alunos, enquanto que no 3 as informações levam em conta os currículos que compõe a universidade.

Será adotado neste trabalho a formulação do \textit{track} 3 por ser considerada, dentre as três, a mais próxima do que acontece na prática nas universidades brasileiras. Esta formulação será explicada em detalhes no capítulo \ref{cap:proposta-trabalho}.

Deseja-se por fim coletar na literatura resultados obtidos para o problema com diferentes técnicas de solução, a fim de comparar com o algoritmo proposto.


\section{Organização do texto}

No capítulo \ref{cap:estado-da-arte} é apresentado o estado da arte listando as principais técnicas de solução do problema. No capítulo \ref{cap:proposta-trabalho} são apresentados a formulação do problema segundo o ITC-2007, o algoritmo GRASP e sua aplicação no problema. No capítulo \ref{cap:resultados} são apresentados detalhes de implementação, instâncias de testes e os resultados obtidos. No capítulo \ref{cap:conclusao} são listadas as conclusões obtidas no trabalho e enumerados alguns trabalhos futuros.


\chapter{Estado da Arte\label{cap:estado-da-arte}}

\vfill{}
\begin{flushright}{}``\emph{Navegar é preciso, viver não.}''\\
{\small Luís de Camões}\end{flushright}{\small \par}
\vfill{}

Neste capítulo são apresentados ....
\newpage


\section{Introdução}

O problema de tabela-horário não possui uma formulação única. Como pode ser visto em \cite{Schaerf95asurvey}, ao longo do tempo surgiram diversas modelagens. Essa variedade surgiu pelo fato das restrições do problema serem específicas a determinada instituição de ensino. Alguns \textit{benchmarks} foram criados, como é o caso do ITC-2007 \cite{itc2007}. A maior contribuição do \textit{benchmark} é fornecer um conjunto de dados para que os diferentes pesquisadores possam comparar suas técnicas de solução.

Apesar das diferentes formulações, os problemas de tabela-horário possuem uma característica em comum: a separação das restrições em dois grupos. São fortes ou fracas.

As restrições fortes são aquelas que não podem ser violadas. Elas restringem o conjunto de soluções para impedir certas situações irreais, como por exemplo, alunos assistindo mais de uma aula no mesmo tempo ou uma sala sendo alocada para mais de uma aula no mesmo horário. Se uma tabela-horário não viola nenhuma restrição forte ela é dita ser uma solução viável.

As restrições fracas são aquelas que não interferem na viabilidade da solução, mas refletem certas preferências das instituições. É desejável, por exemplo, que um aluno não tenha aulas isoladas durante o dia ou que aulas da mesma disciplina sejam lecionadas na mesma sala. As restrições fracas podem possuir pesos diferentes.

O objetivo do problema é encontrar uma tabela-horário viável e que minimize a quantidade de violações fracas, portanto, um problema de minimização.

\section{Conceitos e definições}

As diversas formulações do problema apresentadas na literatura variam devido à instituição envolvida (escola ou universidade) e também pelo conjunto de restrições que são abordadas. Contudo, todas as formulações podem ser classificadas em uma das três classes principais \cite{Schaerf95asurvey}:

\begin{itemize}

\item \textbf{Tabela-horário de Escola} Programação semanal para as turmas da escola, evitando que professores lecionem para duas turmas ao mesmo tempo ou que turmas assistam mais de uma aula no mesmo horário.

\item \textbf{Tabela-horário de Universidade} Programação semanal das aulas das disciplinas universitárias, minimizando a sobreposição de aulas que tenham alunos em comum.

\item \textbf{Tabela-horário de Exames} Programação para aplicação dos exames das disciplinas, evitando sobreposição de exames das disciplinas que tenham alunos em comum, e espalhando os exames para os alunos o máximo possível.

\end{itemize}

A tabela-horário de exames é usada somente nos finais de bimestre, trimestre ou semestre, enquanto as duas primeiras durante todo o período letivo. A diferença principal do problema no âmbito de escolas e universidades é que no segundo não há o conceito de turma, já que cada aluno escolhe o conjunto de disciplinas que irá cursar. Já nas escolas (primárias e secundárias) todos alunos matriculados numa turma cursam as mesmas disciplinas.

\section{Abordagens existentes\label{sec:abordagens}}

As técnicas usadas para resolver o problema de tabela-horário são bastante diversificadas. As mais antigas, as heurísticas construtivas \cite{Junginger:1986:TGS,papoulias}, foram baseadas no modo humano de resolver o problema: as aulas eram alocadas uma a uma até finalizar a construção da tabela. Conflitos eram resolvidos realizando trocas de aulas.

\cite{Neufeld} propôs uma redução do problema ao problema de coloração de grafos. As aulas são representadas como vértices do grafo. Arestas conectam aulas que não podem ser alocadas no mesmo horário. A coloração do grafo resultante é então transformada na tabela-horário: cada cor representa um horário de aula. Propostas similares a esta foram aplicadas em \cite{deWerra85,Selim:1988}.

\cite{deWerra82} reduziram o problema de tabela-horário ao problema de fluxo de redes. As aulas são representadas pelos vértices. Uma rede é criada para cada horário e o fluxo na rede identifica as aulas que são lecionadas no mesmo horário. Posteriormente, \cite{deWerra85} usou uma idéia similar, mas cada fluxo representa uma classe e os vértices são horários e professores. Outras abordagens com fluxo de redes foram usadas em \cite{dinkel1989or,chahal1989}.

De uns anos para cá as técnicas de solução para o problema têm recaído basicamente em três grupos: programação matemática, programação em lógica e principalmente meta-heurísticas.

Na área de programação matemática, bons resultados têm sido obtidos com programação inteira. Em \cite{lach_lubbecke} pode ser vista uma formulação completa do problema. Ela foi executada com CPLEX9 \cite{cplex} e conseguiu soluções com respostas bem próximas às melhores obtidas na competição ITC-2007. Em \cite{Burke_abranch-andcut} pode ser vista outra formulação com algumas relaxações. Com um tempo de execução aproximado de quinze minutos no CPLEX10, esse algoritmo conseguiu encontrar a solução ótima para duas instâncias da competição. Uma grande contribuição destes dois trabalhos é que eles forneceram limites inferiores para a quantidade de violações das restrições fracas para cada instância do ITC-2007. Em \cite{ribeiro2006integer} pode ser vista uma modelagem em programação inteira mais específica para escolas brasileiras de ensino fundamental.

Alguns resultados relevantes também tem sido encontrados com programação em lógica. \cite{springerlink:10.1007/s10479-012-1081-x} apresenta uma formulação usando \textit{MaxSAT} em que se conseguiu melhorar quase metade das respostas que eram conhecidas à época para as instâncias do ITC-2007. \cite{Gueret95buildinguniversity} e \cite{Goltz99universitytimetabling} adotam formulações diferentes do ITC-2007, mas destacam como programação em lógica combinada com programação por restrições podem implementar modelos bem flexíveis, em que restrições podem ser adicionadas, modificadas ou excluídas com pouca alteração de código-fonte.

Pode ser visto em \cite{Lewis2007:survey} que grande parte dos trabalhos recentes na área tem usado meta-heurísticas, tanto pela simplicidade quanto pelos bons resultados alcançados. Meta-heurísticas são estruturas gerais de algoritmos que podem ser adaptados para diferentes problemas de otimização necessitando em geral pouca implementação específica \cite{Lewis2007:survey}.  \textit{Simulated Annealing}, Algoritmo Genético e Busca Tabu são as mais aplicadas. Há propostas com meta-heurísticas menos conhecidas, como a Busca de Harmonia \cite{albetar_harmony}.

Em \cite{Elmohamed98acomparison} foram investigadas diversas abordagens do \textit{Simulated Annealing}. Dentre as configurações possíveis, os melhores resultados foram obtidos com resfriamento adaptativo, reaquecimento e um algoritmo baseado em regras para gerar uma boa solução inicial. \cite{CDGS11b} usa SA para resolver a formulação \textit{track 2} do ITC-2007. Neste trabalho foram obtidas boas respostas para as instâncias, e em alguns casos, foram conhecidas respostas melhores que às conhecidas à época.

Algoritmos Genéticos também foram propostos para o problema. O cromossomo representa a tabela-horário. Cada posição da tabela corresponde a um gene. A partir daí são definidas as operações genéticas de seleção, cruzamento e mutação, que visam gerar indivíduos cada vez melhores. Um indivíduo com bom valor \textit{fitness} representa uma tabela-horário bem avaliada de acordo com a função objetivo associada ao problema. \cite{Erben95agenetic} aplicou esta técnica para tratar o problema de tabela-horário de universidades com muitas restrições, obtendo resultados promissores. Em \cite{Kanoh:2008:KGA} pode ser visto uma abordagem também para universidades, em que se utiliza uma base de conhecimento para gerar a população inicial. Essa base de conhecimento é formada com informações de tabelas-horário de anos anteriores. \cite{massoodian2008} propôs um algoritmo genético híbrido para resolver a formulação do ITC-2007. O algoritmo foi chamado de híbrido porque além de aplicar os operadores genéticos, uma busca local era aplicada nos melhores indivíduos ao final de cada geração.

Um algoritmo mais simples que o genético, mas que também tem sido aplicado é a Busca Tabu. Em \cite{elloumi2008} é apresentado uma algoritmo para resolver o problema de tabela-horário de uma universidade tunisiana. \cite{Santos:2005:TSH} aplicou a técnica no âmbito de escolas primárias e obteve respostas melhores que outros algoritmos propostos com Busca Tabu. Em \cite{Souza:2004:GSA} a Busca Tabu é aplicada como fase de busca local do GRASP, numa implementação também voltada para escolas.

Devido à dificuldade de otimização do problema, alguns autores têm proposto técnicas híbridas, em que são usadas mais de uma meta-heurística ou aplicadas de forma diferente. Exemplos deste tipo de implementação podem ser visto em \cite{massoodian2008} em que o algoritmo genético é combinado com um algoritmo de busca local para melhorar a qualidade das soluções. Em \cite{3-phaseSA} há um algoritmo para o ITC-2002 que constrói a tabela-horário em três etapas. Na primeira é usada um algoritmo de coloração de grafos para se obter uma solução inicial viável. Na segunda e terceira etapas aplica-se \textit{Simulated Annealing}, mas cada uma usando uma estrutura de vizinhança diferente. Como dito anteriormente, em \cite{Souza:2004:GSA} a Busca Tabu é inserida dentro da meta-heurística GRASP para melhorar a fase de busca local desta.

\section{Trabalhos relacionados}

O objetivo deste trabalho é propor um novo algoritmo usando a meta-heurística GRASP para o problema de tabela-horário de universidades. O GRASP já foi implementado no problema, mas para tabela-horário de escolas. Como mostrada na seção anterior, \cite{Souza:2004:GSA} usou o GRASP juntamente com busca Tabu. Outra implementação do GRASP pode ser vista em \cite{Vieira_agrasp}, onde foi implementada a versão básica do algoritmo e uma estratégia de intensificação.

A formulação adotada neste trabalho é a do ITC-2007. Como foi visto na seção \ref{sec:abordagens} muitos trabalhos foram propostos para resolver esta formulação. Mas nenhuma conseguiu obter soluções ótimas para todas as instâncias, o que gera uma motivação para continuar buscando novos resultados. Os melhores resultados encontrados até agora estão em \cite{lach_lubbecke,Burke_abranch-andcut,springerlink:10.1007/s10479-012-1081-x,CDGS11b}.

\chapter{Proposta do trabalho\label{cap:proposta-trabalho}}

\vfill{}
\begin{flushright}{}``\emph{Nada se cria, nada se perde, tudo se
transforma.}''\\
{\small Lavousier}\end{flushright}{\small \par}
\vfill{}

Neste capítulo é apresentado a proposta do trabalho
...
\newpage

\section{Formulação do ITC-2007}

Nesta seção é apresentada a formulação que foi utilizada neste trabalho, que é o \textit{track} 3 do ITC-2007.

O problema de tabela-horário segundo esta formulação utiliza os seguintes parâmetros:

\begin{itemize}

\item \textbf{Dias, Horários e Períodos}: É dado o número de dias na semana em que há aula (geralmente cinco ou seis). Um número fixo de horários de aula, igual para todos os dias, é estabelecido. Um período é um par composto de um dia e um horário. O total de períodos é obtido multiplicando a quantidade de dias pela quantidade de horários do dia.

\item \textbf{Disciplinas e Professores}: Cada disciplina possui uma quantidade de aulas semanais que devem ser alocadas em períodos diferentes. É lecionada por um professor e assistida por um dado número de alunos. Um número mínimo de dias é determinado para a distribuição de suas aulas na semana e é possível que um professor lecione mais de uma disciplina.

\item \textbf{Salas}: Cada sala possui uma capacidade diferente de assentos.

\item \textbf{Currículo}: Um currículo é um grupo de disciplinas que possuem alunos em comum.

\item \textbf{Indisponibilidades} Alguns períodos são indisponíveis para determinadas disciplinas.

\end{itemize}

Uma solução consiste na alocação de cada aula em um período e uma sala. As restrições do problema, fortes e fracas, são descritas a seguir.

\subsection{Restrições Fortes (RFt)}

\begin{itemize}

\item \textbf{Aulas}: Todas as aulas das disciplinas devem ser alocadas e em períodos diferentes. Uma violação ocorre se uma aula não é alocada. (RFt1)

\item \textbf{Conflitos}: Aulas de disciplinas do mesmo currículo ou lecionadas pelo mesmo professor devem ser alocadas em períodos diferentes. (RFt2)

\item \textbf{Ocupação de Sala}: Duas aulas não podem ocupar uma sala no mesmo horário. (RFt3)

\item \textbf{Disponibilidade}: Uma aula não pode ser alocada num horário em que a disciplina é indisponível. (RFt4)

\end{itemize}

\subsection{Restrições Fracas (RFc)}

\begin{itemize}

\item \textbf{Dias Mínimos de Trabalho}: As aulas de cada disciplina devem ser espalhadas por uma quantidade mínima de dias. Cada dia abaixo do mínimo é contado como uma violação. (RFc1)

\item \textbf{Aulas Isoladas}: Aulas do mesmo currículo devem ser alocadas em períodos adjacentes. Cada aula isolada é contada como uma violação. (RFc2)

\item \textbf{Capacidade da Sala}: O número de alunos da disciplina deve ser menor ou igual ao número de assentos da sala em que a aula for dada. Cada aluno excedente contabiliza uma violação. (RFc3)

\item \textbf{Estabilidade de Sala}: Todas as aulas de uma disciplina devem ser dadas na mesma sala. Cada sala distinta é contada como uma violação. (RFc4)

\end{itemize}

Na contagem total das violações fracas são considerados pesos diferentes para cada tipo de violação. A restrição de dias mínimos possui peso cinco, aulas isoladas, peso dois e as demais, peso um.

Uma solução viável deve atender a todas as restrições fortes. Uma solução ótima é viável e minimiza a função objetivo apresentada na equação \ref{funcaoObjetivo}:

\begin{equation}\label{funcaoObjetivo}
%\begin{split}
f = \text{Violações}_{RFt} + \text{Violações}_{RFc}
%\end{split}
\end{equation}

\noindent onde $\text{Violações}_{RFt} = |RFt1|_v + |RFt2|_v + |RFt3|_v + |RFt4|_v$, $\text{Violações}_{RFc} = 5|RFc1|_v + 2|RFc2|_v + |RFc3|_v + |RFc4|_v$ e $|.|_v$ representa o número de violações.

A formulação do ITC-2007 é baseada em casos reais da Escola de Engenharia da Universidade de Udine na Itália. Algumas simplificações foram feitas para o campeonato para manter certo grau de generalidade.

Abaixo está ilustrado um arquivo exemplo para uma instância de teste. A primeira parte informa a quantidade de disciplinas, salas, dias, períodos por dia, currículos e indisponibilidades. Na segunda parte são detalhados dados das disciplinas: nome do professor, quantidade de aulas na semana, número mínimo de dias de aula e quantidade de alunos. A terceira parte lista as salas e suas respectivas capacidades. Logo após vem a relação dos currículos, com os nomes das disciplinas que compõe cada um deles. Por último são listadas as indisponibilidades das disciplinas, identificando dia e horário em que não podem ser lecionadas.

%\begin{boxed}
\begin{verbatim}
Name: Toy
Courses: 4
Rooms: 3
Days: 5
Periods_per_day: 4
Curricula: 2
Constraints: 8

COURSES:
SceCosC Ocra 3 3 30 
ArcTec Indaco 3 2 42 
TecCos Rosa 5 4 40 
Geotec Scarlatti 5 4 18 

ROOMS:
rA 32 
rB 50 
rC 40 

CURRICULA:
Cur1 3 SceCosC ArcTec TecCos 
Cur2 2 TecCos Geotec 

UNAVAILABILITY_CONSTRAINTS:
TecCos 2 0 
TecCos 2 1 
TecCos 3 2 
TecCos 3 3 
ArcTec 4 0 
ArcTec 4 1 
ArcTec 4 2 
ArcTec 4 3 

END.
\end{verbatim}
%\end{boxed}

A figura \ref{fig:solucao_toy} apresenta uma tabela-horário para o exemplo anterior.

\section{Algoritmo GRASP}

Um problema de otimização combinatória pode ser definido por um conjunto finito $E = {1,...,n}$, um conjunto de soluções viáveis $F \subseteq 2^E$ e uma função objetivo $f : 2^E \rightarrow \mathbb{R}$, todos definidos para cada problema específico. Considerando a versão de minimização, o objetivo consiste em encontrar uma solução ótima $S^* \in F$ tal que $f(S^*) \leq f(S), \forall S \in F$. 

As meta-heurísticas são algoritmos gerais que orientam uma forma de explorar o conjunto de soluções para encontrar a solução ótima. A solução ótima não é garantida, mas elas em geral conseguem boas soluções.

A meta-heurística GRASP (\textit{Greedy Randomized Adaptive Search Procedures} - Procedimentos de busca aleatória, adaptativa e gulosa) foi introduzida por \cite{FeoRes89} para tratar o problema de cobertura de conjuntos. De lá para cá ela já foi aplicada em vários problemas de otimização como conjunto independente máximo \cite{FeoResSmi94}, problema quadrático de alocação \cite{LiParRes94}, satisfabilidade \cite{ResFeo96a}, planarização de grafos \cite{ResRib95}, roteamento de circuitos virtuais \cite{ResRib03a}, entre outros.

\subsection{Estrutura básica}

O algoritmo GRASP é um procedimento multi-iterativo. Cada iteração constrói uma solução inicial e aplica busca local para melhorá-la. A resposta final é a melhor obtida dentre as iterações. O algoritmo \ref{algoGrasp} apresenta o pseudo-código genérico do GRASP. Ao fim da fase de construção inicial, pode ocorrer de a solução obtida ser inviável. Por isso um passo intermediário é previsto para reparar a solução, tornando-a viável.

\begin{algorithm}[H]
\label{algoGrasp}
\SetAlgoLined
\SetKwFunction{GeraSolucaoInicial}{GeraSolucaoInicial}
\SetKwFunction{BuscaLocal}{BuscaLocal}
\SetKwFunction{ReparaSolucao}{ReparaSolucao}
%\SetKwFunction{AtualizaPool}{AtualizaPool}
\Entrada{MaxIter}
\Saida{Solução $S^{*}$}

$f^{*} \leftarrow \infty $ \;
\Para{$i\leftarrow 1$ \Ate $MaxIter$}{
	$S \leftarrow GeraSolucaoInicial() $ \;
	\Se{$ S $ é inviável }{
		$ReparaSolucao(S) $\;
	}
	$S \leftarrow BuscaLocal(S) $ \;
	\Se{$ f(S) < f^{*} $}{
		$S^{*} \leftarrow S $ \;
		$f^{*} \leftarrow f(S) $ \;
	}
}
\caption{Estrutura básica do algoritmo GRASP}
\end{algorithm}

O método de construção da solução inicial do GRASP é guloso aleatório e visa produzir um conjunto diversificado de soluções iniciais de boa qualidade para a busca local. Algoritmos totalmente aleatórios conseguem essa diversificação, mas as soluções em geral são ruins considerando a função objetivo. Por outro lado, algoritmos gulosos tendem a gerar soluções de melhor qualidade, mas eles não conseguem produzir soluções diferentes já que a construção é sempre feita por escolhas gulosas.

O algoritmo \ref{solInicialGrasp} ilustra genericamente o procedimento de construção inicial. Ele recebe como parâmetro um conjunto de elementos que irão compor a solução. Cada iteração escolhe sucessivamente um novo elemento candidato para ser incorporado. Essa escolha é gulosa aleatória. Primeiramente todos os candidatos são avaliados por uma função $g(c)$ para medir o custo de adicionar o candidato $c$ à solução parcial $S$. Com base no menor e maior custo são escolhidos os candidatos mais bem avaliados para compor a lista restrita de candidatos - LRC. Um dos candidatos é escolhido aleatoriamente desta lista. Ao ser acrescentado à solução o elemento é retirado do conjunto de candidatos. O procedimento termina quando todos os elementos foram incorporados à solução e não há mais candidatos.

O parâmetro $\alpha (0 \leq \alpha \leq 1)$ regula se o algoritmo será mais guloso ou mais aleatório. Quando $\alpha$ é mais próximo de zero somente os elementos com baixo custo irão entrar na LRC. Este comportamento produz soluções de boa qualidade porém pouco diversificadas. Com $\alpha$ mais próximo de um, elementos com custo mais alto poderão também entrar na LRC. Isto introduz mais aleatoriedade à solução, mas em compensação se perde em qualidade. O ideal é encontrar um valor intermediário que permita diversificação sem prejudicar muito a qualidade de solução que será passada para a fase seguinte de busca local.

\begin{algorithm}[H]
\label{solInicialGrasp}
\SetAlgoLined
\SetKwFunction{GeraSolucaoInicial}{GeraSolucaoInicial}
\SetKwFunction{BuscaLocal}{BuscaLocal}
\SetKwFunction{PathRelinking}{PathRelinking}
\SetKwFunction{AtualizaPool}{AtualizaPool}
\Entrada{E = \{conjunto discreto finito\}}
\Saida{Solução S}

$S \leftarrow \emptyset $ \;
$C \leftarrow E $ \;
\Enqto{$|C| > 0$}{
	Para todo $c \in C$ computar o valor da função gulosa $g(c) $ \;
	$c^{min} \leftarrow min\{g(c) | c \in C\}$\;
	$c^{max} \leftarrow max\{g(c) | c \in C\}$\;
	$LRC \leftarrow \{ c \in C | g(c) \leq c^{min} + \alpha(c^{max} - c^{min}) \} $ \;
	Escolha aleatoriamente $c^{'} \in LRC $ \;
	$S \leftarrow S \bigcup \{ c^{'} \} $\;
	$C \leftarrow C - \{ c^{'} \}$ \;
}
\caption{Algoritmo guloso aletório para construção da solução inicial do GRASP}
\end{algorithm}

Para encontrar boas soluções, uma meta-heurística precisa ter duas características importantes: diversificação e intensificação. A primeira se refere à capacidade de explorar bem o espaço de soluções e não ficar preso a mínimos ou máximos locais. A intensificação é necessária para explorar bem uma região de mínimo local, dado que o mínimo global necessariamente também é um mínimo local.

No GRASP a diversificação é feita pela independência das iterações e pela aleatoriedade introduzida na solução inicial. Assim a busca local irá trabalhar em diferentes soluções.

A intensificação é feita pela busca local. Nesta fase a solução inicial é melhorada explorando sua vizinhança na busca de soluções melhores. O GRASP não especifica qual a estratégia de busca local deve ser utilizada. Em \cite{FeoResSmi94} a busca local implementada é conhecida como \textit{Hill Climbing}. É uma estratégia simples em que se explora a vizinhança enquanto são encontradas soluções melhores. Já em \cite{Souza:2004:GSA} por exemplo, é usado busca Tabu.

\subsection{Hibridização com \textit{Path-Relinking}}

A heurística \textit{Path-Relinking} (religamento de caminhos) foi originalmente proposta por \cite{Glover96tabusearch} como uma estratégia de intensificação na busca Tabu. A primeira proposta de uso do \textit{Path-Relinking} no GRASP foi feita por \cite{Laguna99graspand}. Essa hibridização tenta resolver uma deficiência do GRASP que é ausência de memorização entre as iterações.

A idéia básica do \textit{Path-Relinking} é traçar um caminho ligando duas soluções, que são chamadas de inicial e alvo. Para gerar este caminho, sucessivamente são inseridos atributos da solução alvo na solução inicial para que ela fique a cada iteração mais parecida com a solução alvo. A cada atributo inserido uma solução diferente é obtida. A melhor solução obtida no caminho é a resposta do algoritmo. Desta forma, o religamento de caminhos pode ser visto como uma estratégia que procura incorporar atributos de soluções de alta qualidade. O pseudo-código do algoritmo \ref{path-relinking} ilustra o PR aplicado ao par de soluções $x_i$ (inicial) e $x_a$ (alvo).

O procedimento inicia computando a diferença simétrica $\Delta(x_i,x_a)$ entre as duas soluções, isto é, o conjunto de movimentos necessários para alcançar $x_a$ a partir de $x_i$. Um caminho de soluções é gerado ligando $x_i$ e $x_a$. A melhor solução $x^*$ no caminho é retornada pelo algoritmo. Em cada iteração, o procedimento examina todos os movimentos $m \in \Delta(x, x_a)$ a partir da solução corrente $x$ e seleciona aquele que resulta no custo de solução menor, isto é, aquele que minimiza $f(x \oplus m)$, onde $x \oplus m$ é a solução resultante da aplicação do movimento $m$ à solução $x$. O melhor movimento $m^*$ é feito, produzindo a solução $x \oplus m^*$. O conjunto de movimentos possíveis é atualizado. Se for o caso, a melhor solução $x^*$ é atualizada. O procedimento termina quando $x_a$ é alcançada, ou seja, $\Delta(x, x_a) = \emptyset$.

\begin{algorithm}[H]
\label{path-relinking}
\SetAlgoLined
\SetKwFunction{GeraSolucaoInicial}{GeraSolucaoInicial}
\SetKwFunction{BuscaLocal}{BuscaLocal}
\SetKwFunction{PathRelinking}{PathRelinking}
\SetKwFunction{AtualizaPool}{AtualizaPool}
\Entrada{Solução inicial $x_i$, solução alvo $x_a$}
\Saida{Melhor solução $x^{*}$ no caminho de $x_i$ para $x_a$}

$f^{*} \leftarrow min \{ f(x_i), f(x_a) \} $ \;
$x^{*} \leftarrow argmin \{ f(x_i), f(x_a) \} $ \;
$x \leftarrow x_i $ \;
Compute as diferenças simétricas $\Delta(x,x_a) $ \;
\Enqto{$\Delta(x,x_a) \neq \emptyset $}{
	$m^* \leftarrow argmin  \{ f(x \oplus m) : m \in \Delta(x,x_a) \}$ \;
	$ \Delta(x \oplus m^*,x_a) \leftarrow \Delta(x,x_a) - \{ m^* \}$ \;
	$ x \leftarrow x \oplus m^* $ \;
	\Se{$ f(x) < f^* $}{
		$f^* \leftarrow f(x) $ \;
		$x^* \leftarrow x $ \;
	}
}
\caption{Algoritmo \textit{Path-Relinking}}
\end{algorithm}

O \textit{Path-Relinking} pode ser visto com uma estratégia de busca local mais restrita, onde os movimentos aplicados são mais específicos.

De acordo com \cite{Resende05graspwith}, \textit{Path-Relinking} é uma melhoria ao algoritmo básico do GRASP, proporcionando melhoras tanto no tempo quanto na qualidade de solução, e pode ser aplicada de duas formas diferentes:

\begin{itemize}

\item PR é aplicado entre todos os pares de soluções elite. Pode ser feito periodicamente durante as iterações do GRASP ou no final da execução como uma pós-otimização.

\item PR é aplicado como estratégia de intensificação em cada mínimo local obtido logo após a fase de busca local.

\end{itemize}

O algoritmo \ref{algoGraspComPathRelinking} ilustra as duas estratégias embutidas na versão básica do GRASP. O \textit{Path-Relinking} é aplicado entre duas soluções $x$ e $y$: $x$ é um ótimo local obtido na busca local e $y$ é uma solução escolhida aleatoriamente do conjunto de soluções elite. Esse procedimento é aplicado somente a partir da segunda iteração dado que na primeira o conjunto elite está vazio. Esse conjunto é limitado e tem tamanho $MaxElite$.

Ao final de cada iteração o conjunto elite ele é atualizado. Todo ótimo local obtido é candidato a entrar no conjunto. Se ele já tem $MaxElite$ soluções, o candidato só irá entrar se for diferente das soluções presentes e melhor que ao menos uma delas. Esse controle de quem entra e sai do conjunto é implementado pelo procedimento $AtualizaPool$.

Ao final das iterações ocorre a pós-otimização, em que se aplica \textit{Path-Relinking} entre as soluções do conjunto elite, duas as duas. A melhor solução obtida é a resposta do algoritmo.

\begin{algorithm}[H]
\label{algoGraspComPathRelinking}
\SetAlgoLined
\SetKwFunction{GeraSolucaoInicial}{GeraSolucaoInicial}
\SetKwFunction{BuscaLocal}{BuscaLocal}
\SetKwFunction{PathRelinking}{PathRelinking}
\SetKwFunction{AtualizaPool}{AtualizaPool}
\Entrada{MaxIter, MaxElite}
\Saida{Solução $S^{*}$}

$f^{*} \leftarrow \infty $ \;
$Elite \leftarrow \emptyset $ \;
\Para{$i\leftarrow 1$ \Ate $MaxIter$}{
	$S \leftarrow GeraSolucaoInicial() $ \;
	$S \leftarrow BuscaLocal(S) $ \;
	\Se{$ i \geq 2 $}{
		Selecione aleatoriamente $S_{elite} \in Elite $ \;
		$S \leftarrow PathRelinking(S, S_{elite}) $ \;
	}
	\Se{$ f(S) < f^{*} $}{
		$S^{*} \leftarrow S $ \;
		$f^{*} \leftarrow f(S) $ \;
	}
	$AtualizaPool(S, Elite)$ \;
}
$S^* = PosOtimizacao(Elite)$ \;
\caption{Algoritmo GRASP com \textit{Path-Relinking} para intensificação e pós-otimização}
\end{algorithm}

\section{GRASP para o ITC-2007}

Nesta seção será apresentada a implementação do GRASP para o problema de tabela-horário segundo a formulação 3 do ITC-2007. A implementação ficou com uma estrutura similar ao algoritmo \ref{algoGraspComPathRelinking}, com três fases principais em cada iteração: geração da solução inicial, busca local e \textit{path-relinking}.

\subsection{Geração de tabela-horário inicial}

O objetivo da etapa de construção inicial é produzir uma tabela-horário viável, e se possível, com poucas violações das restrições fracas. O GRASP não exige que a solução inicial seja viável, mas foi decidido implementar desta forma para que nas fases seguintes o algoritmo concentre apenas na eliminação das violações das restrições fracas.

Partindo de uma tabela-horário vazia, as aulas são acrescentadas uma a uma até que todas estejam alocadas. A escolha é tanto gulosa (para produzir soluções de boa qualidade) quanto aleatória (para produzir soluções diversificadas).

Com intuito de se conseguir uma solução viável, é adotada uma estratégia de alocar as aulas mais conflitantes primeiro. Poucos horários são viáveis para as disciplinas mais conflitantes, portanto, é melhor alocá-las quando a tabela está mais vazia. Para medir se uma aula é mais conflitante que outra são contados quantos horários (dentre os desocupados) servem para alocar a aula da disciplina. Esta contagem envolve:

\begin{itemize}

\item retirar os horários em o que o professor da disciplina já leciona alguma aula,
\item retirar os horários em que estão alocadas disciplinas do mesmo currículo, e
\item retirar os horários que são indisponíveis para a disciplina segundo a restrição de indisponibilidade.

\end{itemize}

Em cada iteração, a aula mais difícil é escolhida para ser alocada. Existem diferentes combinações de horários e salas para a alocação. Os custos de todas essas combinações são calculados levando-se em conta as penalizações das restrições fracas. As combinações que possuem horários inviáveis são descartadas. Com base no menor e maior custo de adição de um elemento à solução ($c^{min}$ e $c^{max}$) é construída a lista restrita de candidatos (LRC). Estarão na LRC as aulas cujos custos estejam no intervalo \begin{math} [c^{min}, c^{min}+\alpha(c^{max} - c^{min})]\end{math}. Uma aula é escolhida aleatoriamente da LRC e acrescentada à solução.

É possível que em alguns casos, ao escolher uma aula para alocar não haja um horário que mantenha a viabilidade da solução. Para contornar esta situação foi implementado um procedimento denominado "explosão". É uma estratégia que retira da tabela uma aula alocada anteriormente para abrir espaço para a aula que não está sendo possível alocar. A aula retirada volta para o conjunto de aulas não alocadas.

A primeira estratégia de explosão foi escolher o horário que possui menos disciplinas conflitantes e retirar todas elas da tabela. Essa estratégia não foi muito eficaz porque introduziu certa ciclagem no algoritmo, retirando uma aula e alocando outra, mas posteriormente fazendo o inverso, já que o horário escolhido era quase sempre o mesmo.

Uma estratégia que foi mais eficaz foi escolher um horário aleatoriamente, ao invés de selecionar aquele com menos aulas conflitantes. Testes mostraram que essa estratégia se livra melhor do problema de ciclagem.

O algoritmo \ref{solInicialGrasp-ITC2007} ilustra o procedimento de geração de uma tabela-horário inicial. Ele recebe como parâmetro as aulas das disciplinas para serem alocadas na tabela que inicialmente é vazia. Para facilitar a recuperação da aula mais conflitante é criada uma lista de aulas não alocadas. Esta lista é ordenada de forma decrescente pela quantidade de conflitos, portanto a aula na primeira posição da lista é a mais conflitante.

A cada iteração a aula mais conflitante que ainda não foi alocada é selecionada. Em seguida é verificado em quais horários pode ser alocada a aula sem gerar inviabilidades. Se não houver horário disponível ocorre a explosão, portanto, pelo menos em um horário poderá ocorrer a alocação. Os horários disponíveis são combinados com todas as salas, e é feita uma avaliação do custo alocar a aula na respectiva sala e horário. Com base nos custos é construída a lista restrita de candidatos. A aula é então inserida na tabela numa posição escolhida aleatoriamente da LRC. A lista de aulas não alocadas é atualizada e ordenada novamente. Essa ordenação é necessária porque a última aula alocada poderá gerar conflitos com as aulas que ainda serão aloacadas. O procedimento termina quando todas aulas estão alocadas.

\begin{algorithm}[H]
\label{solInicialGrasp-ITC2007}
\SetAlgoLined
\SetKwFunction{GeraSolucaoInicial}{GeraSolucaoInicial}
\SetKwFunction{BuscaLocal}{BuscaLocal}
\SetKwFunction{PathRelinking}{PathRelinking}
\SetKwFunction{OrdenaAulasPorDificuldade}{OrdenaAulasPorDificuldade}
\Entrada{A = \{conjunto de aulas\}, $\alpha$}
\Saida{Tabela-horário T}

$T \leftarrow \emptyset $ \;
$ListaNaoAlocadas \leftarrow GeraListaNaoAlocadas(A) $ \;
$OrdenaAulasPorConflitos(ListaNaoAlocadas) $ \;
\Enqto{$|ListaNaoAlocadas| > 0$}{
	$ a \leftarrow ListaNaoAlocadas[0] $ \;
	$H \leftarrow h | h $ é viável para $ a $ \;
	\Se{$ H = \emptyset $}{
		ExplodeSolucao(T, a) \;
		$H \leftarrow h | h $ é viável para $ a $ \;
	}
	Para todo $ (s, h) \in S \times H, T[s, h] = \emptyset $, computar o custo de alocação $f(a,s,h) $ \;
	$c^{min} \leftarrow min\{f(a,s,h) | (s, h) \in S \times H\}$\;
	$c^{max} \leftarrow max\{f(a,s,h) | (s, h) \in S \times H\}$\;
	$LRC \leftarrow \{ (s,h) \in S \times H | f(a,s,h) \leq c^{min} + \alpha(c^{max} - c^{min}) \} $ \;
	Escolha aleatoriamente $(s',h') \in LRC $ \;
	$T[s',h'] = a $\;
	$RetiraAula(ListaNaoAlocadas, a) $ \;
	$OrdenaAulasPorConflitos(ListaNaoAlocadas) $ \;
}
\caption{Algoritmo construtivo para geração de tabela-horário inicial}
\end{algorithm}

\subsection{Buscal local}

\subsection{Path-relinking}




\begin{algorithm}[H]
\label{algoBase}
\SetAlgoLined
\SetKwFunction{GeraSolucaoInicial}{GeraSolucaoInicial}
\SetKwFunction{BuscaLocal}{BuscaLocal}
\SetKwFunction{PathRelinking}{PathRelinking}
\SetKwFunction{AtualizaPool}{AtualizaPool}
\Entrada{Instância p, MaxIter, TamPool}
\Saida{Solução $S^{*}$}

$f^{*} \leftarrow \infty $ \;
$Pool \leftarrow \phi $ \;
\Para{$i\leftarrow 1$ \Ate $MaxIter$}{
	$S \leftarrow GeraSolucaoInicial() $ \;
	$S \leftarrow BuscaLocal(S) $ \;
	\Se{$ i > TamPool $}{
		Selecione aleatoriamente $S_{elite} \in Pool $ \;
		$S \leftarrow PathRelinking(S, S_{elite}) $ \;
	}
	\Se{$ f(S) < f^{*} $}{
		$S^{*} \leftarrow S $ \;
		$f^{*} \leftarrow f(S) $ \;
	}
	$AtualizaPool(S, Pool)$ \;
}
\caption{Algoritmo GRASP}
\end{algorithm}


\chapter{Resultados Computacionais\label{cap:resultados}}

\vfill{}
\begin{flushright}{}``\emph{Nada se cria, nada se perde, tudo se
transforma.}''\\
{\small Lavousier}\end{flushright}{\small \par}
\vfill{}

Neste capítulo é apresentado os resultados computacionais
...
\newpage

\section{Descrição das instâncias utilizadas}

As instâncias utilizadas foram as mesmas submetidas aos competidores do ITC-2007.
São 21 instâncias ao todo, com grau de dificuldade variado. A organização garante que existe solução viável para todas as instâncias, fato que foi comprovado nos testes. Mas nada foi informado sobre a quantidade de violações fracas em cada instância. Em \cite{itc2007} podem ser obtidas todas as instâncias.

Na tabela \ref{tab:instancias} são apresentados os dados mais relevantes de cada instância. A quantidade de horários de aula numa semana não varia muito de instância para instância. A coluna conflitos conta a quantidade de pares de aula que não podem ser alocadas no mesmo horário (mesma disciplina, mesmo currículo ou mesmo professor) dividido pelo total de pares distintos de aula. A disponibilidade mede percentualmente a quantidade de horários que são disponíveis para as aulas, levando-se em conta as restrições de indisponibilidade que são informadas no arquivo de entrada.

A quantidade de currículos e disciplinas tem grande impacto no tempo de execução do algoritmo, pois são mais aulas para fazer a contagem total de violações. A quantidade de conflitos e disponibilidade influencia na dificuldade de encontrar uma solução viável, pois quanto mais conflitos e menos disponibilidade, menos horários existirão para alocar aula sem violar as restrições fortes. Além de dificultar a viabilidade no momento de geração da solução inicial, os conflitos e as disponibilidades dificultam a exploração da vizinhança na busca local, dado que muitas trocas acabam sendo descartadas por introduzirem violações das restrições fortes.

\begin{center}
\begin{table}[!htb]
\begin{tabular}{|c|c|c|c|c|c||c|c|}\hline
{\bf Instância} & {\bf Currículos} & {\bf Salas} & {\bf Disciplinas} &{\bf Horários por dia}&{\bf Dias}&{\bf Conflitos} & {\bf Disponibilidade}\\\hline
comp01 & 14 & 6 & 30 & 6 & 5 & 13.2 & 93.1 \\ 
comp02 & 70 & 16 & 82 & 5 & 5 & 7.97 & 76.9 \\ 
comp03 & 68 & 16 & 72 & 5 & 5 & 8.17 & 78.4 \\ 
comp04 & 57 & 18 & 79 & 5 & 5 & 5.42 & 81.9 \\ 
comp05 & 139 & 9 & 54 & 6 & 6 & 21.7 & 59.6 \\ 
comp06 & 70 & 18 & 108 & 5 & 5 & 5.24 & 78.3 \\ 
comp07 & 77 & 20 & 131 & 5 & 5 & 4.48 & 80.8 \\ 
comp08 & 61 & 18 & 86 & 5 & 5 & 4.52 & 81.7 \\ 
comp09 & 75 & 18 & 76 & 5 & 5 & 6.64 & 81 \\ 
comp10 & 67 & 18 & 115 & 5 & 5 & 5.3 & 77.4 \\ 
comp11 & 13 & 5 & 30 & 9 & 5 & 13.8 & 94.2 \\ 
comp12 & 150 & 11 & 88 & 6 & 6 & 13.9 & 57 \\ 
comp13 & 66 & 19 & 82 & 5 & 5 & 5.16 & 79.6 \\ 
comp14 & 60 & 17 & 85 & 5 & 5 & 6.87 & 75 \\ 
comp15 & 68 & 16 & 72 & 5 & 5 & 8.17 & 78.4 \\ 
comp16 & 71 & 20 & 108 & 5 & 5 & 5.12 & 81.5 \\ 
comp17 & 70 & 17 & 99 & 5 & 5 & 5.49 & 79.2 \\ 
comp18 & 52 & 9 & 47 & 6 & 6 & 13.3 & 64.6 \\ 
comp19 & 66 & 16 & 74 & 5 & 5 & 7.45 & 76.4 \\ 
comp20 & 78 & 19 & 121 & 5 & 5 & 5.06 & 78.7 \\ 
comp21 & 78 & 18 & 94 & 5 & 5 & 6.09 & 82.4 \\
\hline
\end{tabular}
\caption{Tabela com informações sobre cada instância do ITC-2007}
\label{tab:instancias}
\end{table}
\end{center}


\section{Detalhes de implementação}

representação dos dados

matrizes auxiliares

\section{Sintonia da Meta-heurística}



Duas estruturas de vizinhança foram usadas neste trabalho para a fase de busca local: \textit{MOVE} e \textit{SWAP}. Em \cite{CDGS11b} essas duas estruturas também são usadas, só que aplicadas de maneira diferente. Na geração do vizinho sempre é usado o \textit{MOVE}. Em alguns casos ocorre \textit{SWAP} juntamente com o \textit{MOVE}. Essa probabilidade de ocorrer o \textit{SWAP} foi parametrizada. Experimentalmente foi escolhido um valor de $40\%$.

Testes mostraram que aplicar \textit{MOVE} e \textit{SWAP} separadamente é mais eficiente. Foi observado que separadamente eles produzem melhores soluções e de forma mais rápida. Cada um ocorre com a mesma probabilidade de $50\% $.

\begin{itemize}

\item Temperatura inicial do SA para busca local

\end{itemize}

\section{Análise dos resultados}


\chapter{Conclusões e trabalhos futuros\label{cap:conclusao}}

\vfill{}
\begin{flushright}{}``\emph{Nada se cria, nada se perde, tudo se
transforma.}''\\
{\small Lavousier}\end{flushright}{\small \par}
\vfill{}

Neste capítulo é apresentado as conclusões e alguns trabalhos futuros
...
\newpage


\section{Conclusões}

{\bf Alguns itens interessantes para a conclusão de um projeto de graduação}

Qual foi o resultado do seu trabalho? melhora na área, testes positivos ou negativos?
Você acha que o mecanismo gerado produziu resultados interessantes?
Quais os problemas que você encontrou na elaboração do projeto?
E na implementação do protótipo?
Que conclusão você tirou das ferramentas utilizadas? (heurísticas, prolog, ALE, banco de dados).
Em que outras áreas você julga que este trabalho seria interessante de ser aplicado?
Que tipo de continuidade você daria a este trabalho?
Que tipo de conhecimento foi necessário para este projeto de graduação?
Para que serviu este trabalho na sua formação?


\bibliographystyle{abnt-alf}
\bibliography{monografia}


\anexo


\chapter{Ferramentas utilizadas}

Foi feita uma análise de algumas ferramentas que são muito usadas
por atacantes (hackers) para a confecção de ataques. Estas ferramentas
são muito úteis em vários aspectos, tais como: (1) o levantamento
de informações sobre o alvo, (2) que tipo de serviços estão disponíveis
no alvo, (3) quais as possíveis vulnerabilidades do alvo, entre outras
informações. As ferramentas analisadas foram o \emph{nmap}~\cite{Io02},
o \emph{nessus}~\cite{NP02}, o \emph{saint}~\cite{SC02}, além
de alguns comandos de sistemas operacionais (UNIX-Like e Windows-Like)
usados para rede, tais como o \emph{ping, nslookup e whois}. 
\end{document}
